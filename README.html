<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>The Playground &#x2013; My Solution</title>
<meta  name="generator" content="Org-mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">The Playground &#x2013; My Solution</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">1. The Problem</a></li>
<li><a href="#orgheadline2">2. Modeling the Problem</a></li>
<li><a href="#orgheadline7">3. Setting up the Graph</a>
<ul>
<li><a href="#orgheadline3">3.1. Platform Trampoline (A3, green)</a></li>
<li><a href="#orgheadline4">3.2. NEWS Slide (A1, red)</a></li>
<li><a href="#orgheadline5">3.3. Human Cannon (A2, blue)</a></li>
<li><a href="#orgheadline6">3.4. EOF Wormhole (A4, orange)</a></li>
</ul>
</li>
<li><a href="#orgheadline17">4. Annotated Code</a>
<ul>
<li><a href="#orgheadline8">4.1. Includes</a></li>
<li><a href="#orgheadline9">4.2. Structs</a></li>
<li><a href="#orgheadline10">4.3. Prototypes</a></li>
<li><a href="#orgheadline11">4.4. Graph</a></li>
<li><a href="#orgheadline12">4.5. Queue</a></li>
<li><a href="#orgheadline13">4.6. Flow</a></li>
<li><a href="#orgheadline14">4.7. Sorting</a></li>
<li><a href="#orgheadline15">4.8. Hashing</a></li>
<li><a href="#orgheadline16">4.9. Main</a></li>
</ul>
</li>
<li><a href="#orgheadline18">5. Sample running times</a></li>
<li><a href="#orgheadline19">6. License</a></li>
</ul>
</div>
</div>
<p>
This is an informal description of my solution to an internal programming competition in my algorithms and data structures course.
The competition has ended, but at the time of writing winners have not been announced.
I hold second place based on test cases behind an implementation in Python, so this can't be optimal, but not that bad either.
</p>

<p>
The code is a single file and should built easily with both GCC and Clang, I use the following with varying degrees of optimization:
</p>

<pre class="example">
clang -g -O2 -Weverything -std=c11 playground.c -o playground
</pre>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1"><span class="section-number-2">1</span> The Problem</h2>
<div class="outline-text-2" id="text-1">
<p>
<a href="http://www2.compute.dtu.dk/courses/02110/ThePlayground.pdf">The original  problem statement is available online</a>, I will describe the problem here as well.
</p>

<p>
The program is given a list of platforms on standard input.
I will use the input in listing <a href="#orgsrcblock1">1</a> as a running example.
</p>

<div class="org-src-container">
<label class="org-src-name">Sample input for a problem with 8 platforms</label>
<pre class="src src-text" id="orgsrcblock1">8
0 1 4 0 2 0
2 2 1 2 3 4
4 1 3 1 1 0
4 3 1 0 0 1
6 4 0 0 1 1
9 1 1 0 0 2
9 4 2 0 0 1
9 3 0 0 0 0
</pre>
</div>

<p>
The first line is the number of platforms, P, the next P lines are the platforms specified by six parameters: x- and y-coordinate and four capacities.
The platforms are implicitly numbered by their position in the input and their positions are distinct.
We're given at least two platforms and at most 100.000.
Both coordinates and capacities are between 0 and 100.000.
The input is illustrated in figure <a href="#orgparagraph1">1</a>.
</p>


<div id="orgparagraph1" class="figure">
<p><img src="./figures/platforms.gif" alt="platforms.gif" />
</p>
<p><span class="figure-number">Figure 1:</span> Visualisation of the sample input</p>
</div>

<p>
Now the thing is that we need to turn this set of platforms into a playground, where you enter at platform 0 and leave from platform P-1.
To do this we will build activities from one platform to another.
There are four kinds of activities, and the four capacities specify how many of each of these can be build from a specific platform.
A trail is a path via a unique set of activities from the start-platform to the end-platform and the task is to maximize the number of trails.
The only output produced is the maximum number of trails; we don't need to print how activities are placed etc.
</p>

<p>
The four different activities are (taken almost verbatim from the problem description):
</p>

<dl class="org-dl">
<dt>NEWS<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> Slide (A1, red)</dt><dd>Can be built from a platform A to any other platform with the same x- or y-coordinate as A. That is, any platform on the same horizontal or vertical line as A.</dd>
<dt>Human Cannon (A2, blue)</dt><dd>Can be built from a platform A to the platform furthest away from A in euclidean distance. In case of a tie, the platform that appeared first in the input wins.</dd>
<dt>Platform Trampoline (A3, green)</dt><dd>Can be built from a platform A to a platform B if there are at least 2 platforms on the line segment between A and B.</dd>
<dt>EOF<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup> Wormhole (A4, orange)</dt><dd>Can be built from any platform directly to the end-platform.</dd>
</dl>

<p>
These are illustrated (without capacities) one by one on figures <a href="#orgparagraph2">2</a>, <a href="#orgparagraph3">3</a>, <a href="#orgparagraph4">4</a>, <a href="#orgparagraph5">5</a> and together on figure <a href="#orgparagraph6">6</a>.
</p>


<div id="orgparagraph2" class="figure">
<p><img src="./figures/a1.gif" alt="a1.gif" />
</p>
<p><span class="figure-number">Figure 2:</span> A1s (same horisontal or vertical line)</p>
</div>


<div id="orgparagraph3" class="figure">
<p><img src="./figures/a2.gif" alt="a2.gif" />
</p>
<p><span class="figure-number">Figure 3:</span> A2s (furthest away)</p>
</div>


<div id="orgparagraph4" class="figure">
<p><img src="./figures/a3.gif" alt="a3.gif" />
</p>
<p><span class="figure-number">Figure 4:</span> A3s (2 or more platforms in-between)</p>
</div>


<div id="orgparagraph5" class="figure">
<p><img src="./figures/a4.gif" alt="a4.gif" />
</p>
<p><span class="figure-number">Figure 5:</span> A4s (end of fun)</p>
</div>


<div id="orgparagraph6" class="figure">
<p><img src="./figures/a1234.gif" alt="a1234.gif" />
</p>
<p><span class="figure-number">Figure 6:</span> All possible activities for the sample input</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2"><span class="section-number-2">2</span> Modeling the Problem</h2>
<div class="outline-text-2" id="text-2">
<p>
We are going to solve this a <a href="https://en.wikipedia.org/wiki/Maximum_flow_problem">maximum flow problem</a>, and I'll assume the reader is familiar with these.
</p>

<p>
If one can follow activities from the start-platform to the end-platform then this corresponds to flow from the source to the sink of the corresponding flow network.
The maximum flow through this network will be the maximum number of trails.
Actually figure <a href="#orgparagraph6">6</a> is exactly this flow network for the sample input, so the correspondence is very direct.
</p>

<p>
The problem with the graph in figure <a href="#orgparagraph6">6</a> is that it has vertex capacities instead of edge capacities that an off-the-shelf maximum flow algorithm expects.
So we need to transform the graph a bit before we can use it.
</p>

<p>
The technique for converting vertex capacities into edge capacities is well known.
The trick is to insert a dummy vertex as in figure <a href="#orgparagraph7">7</a>.
</p>


<div id="orgparagraph7" class="figure">
<p><img src="./figures/vertexcapacity.gif" alt="vertexcapacity.gif" />
</p>
<p><span class="figure-number">Figure 7:</span> Converting a vertex capacity into an edge capacity</p>
</div>

<p>
Any incoming edges will still go to the original vertex, but any outgoing will start at the new vertex instead.
Now to get from the old vertex to the new vertex, the flow must cross an edge with the capacity of the old vertex.
This is equivalent to the vertex having the capacity.
</p>

<p>
So it's easy to convert a graph where vertices have a single capacity to one with edge capacities instead, but our graph has four vertex capacities.
It turns out that we can just insert four dummy vertices instead of one and it works.
Our platforms from figure <a href="#orgparagraph1">1</a> now look like in figure <a href="#orgparagraph8">8</a>.
Notice how the original capacities can now be read off the edges instead of the vertices.
</p>


<div id="orgparagraph8" class="figure">
<p><img src="./figures/edgecaps.gif" alt="edgecaps.gif" />
</p>
<p><span class="figure-number">Figure 8:</span> Our sample platforms with edge capacities</p>
</div>

<p>
The vertex numbering scheme is as follows:
For a platform i, the four new vertices are named i+x&sdot; P where Ax is the matching activity and P still the total number of platforms.
So any A1 activities from the start-platform (i=0) in our example will now go from platform 0+1&sdot; 8=8 instead.
Notice that this is colored red in figure <a href="#orgparagraph8">8</a> as expected .
</p>

<p>
The final graph which we can run a standard flow algorithm on is given in figure <a href="#orgparagraph9">9</a>.
The original vertices are black, as are their edges to the new vertices.
The new vertices are colored by the activity whose capacity they match.
Compare this to one of the first four graphs: All edges are still there, they just start at one of the new nodes, but still go to an original node.
</p>


<div id="orgparagraph9" class="figure">
<p><img src="./figures/a1234all.gif" alt="a1234all.gif" />
</p>
<p><span class="figure-number">Figure 9:</span> The final flow network</p>
</div>

<p>
I'm using Edmonds-Karp to find the actual maximum flow, a possible solution with maximum flow 5 can be seen on figure <a href="#orgparagraph10">10</a>.
This doesn't use A2-activities at all, but is the one my implementation finds.
One trail consists of going from 0 to 4 with an A3-activity, of which 2 can be built from 0, and then from 4 to 7 with an A4-activity.
Another trail uses A1-activities to go from 0 to 1 to 7, and so on.
</p>


<div id="orgparagraph10" class="figure">
<p><img src="./figures/sol.gif" alt="sol.gif" />
</p>
<p><span class="figure-number">Figure 10:</span> One solution to the sample input</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-2">
<h2 id="orgheadline7"><span class="section-number-2">3</span> Setting up the Graph</h2>
<div class="outline-text-2" id="text-3">
<p>
Now we know how to model the problem as something we can solve with an off-the-shelf algorithm, so we just need to set up this flow network efficiently.
</p>

<p>
I'll start with the most interesting activity, A3, as this will dictate how much effort we spend on the rest.
I will describe constructing an activity between two platforms, so just remember that this actually means from the proper dummy vertex of the first platform, to the other platform as described in the previous section.
</p>
</div>

<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3"><span class="section-number-3">3.1</span> Platform Trampoline (A3, green)</h3>
<div class="outline-text-3" id="text-3-1">
<p>
The algorithm for constructing these activities is actually quite simple, but it took me a while to figure it out.
A partial run is animated on figure <a href="#orgparagraph11">11</a>.
</p>

<p>
What we want to do is consider each platform in order.
Then when considering a platform, we want to consider a different one and as efficiently as possible, determine whether it is legal to make an A3-activity between the two.
</p>

<p>
The trick is to look at the platforms, not in the order they're given, but from left to right, and from the bottom up.
And furthermore to only look at platforms to the right and up, when already considering one.
This guarantees that we look at platforms on the same line in order by their distance.
That is, when multiple platforms lie on the same line given an origin, we will see the closest one first, then the second-closest etc.
</p>

<p>
The algorithm then becomes
</p>

<ul class="org-ul">
<li>Sort the platforms by x- then y-coordinate (left to right, bottom up)</li>
<li>Initialize an empty hashtable</li>
<li>For each platform p
<ul class="org-ul">
<li>For each platform q ahead of p in the sorted order
<ul class="org-ul">
<li>Calculate the slope between p and q</li>
<li>Look up the slope in our hash table</li>
<li>If the value associated with the slope is 2 (or more), draw an A3-activity from p to q and from q to p</li>
<li>Otherwise, increase the count</li>
</ul></li>
<li>Clear the hash table</li>
</ul></li>
</ul>

<p>
We have to draw the activity in both directions because we only look ahead in the sorted order.
</p>

<p>
Looking at figure <a href="#orgparagraph11">11</a>, the count associated with each slope is noted next to its blue line.
Platforms are marked red when visited but no activity is built and green when one is.
We see that the only platform to which an A3-activity can be built from 0 is number 4 as expected.
</p>


<div id="orgparagraph11" class="figure">
<p><img src="./figures/slopes/slopes.gif" alt="slopes.gif" />
</p>
<p><span class="figure-number">Figure 11:</span> Partial run of algorithm for determining valid A3-activities</p>
</div>


<p>
With expected constant time lookup in the hash table, the above runs in O(P<sup>2</sup>) time.
That's the best upper bound we can hope for, as there might be upwards of P<sup>2</sup> legal A3-activities; consider the case where all platforms lie on a single line.
Unfortunately this is also the lower bound of the algorithm: we always spend O(P<sup>2</sup>) time, even if no A3-activities can be constructed.
I would love to solve this with a lower bound of &Omega;(Plog P) or something instead.
</p>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4"><span class="section-number-3">3.2</span> NEWS Slide (A1, red)</h3>
<div class="outline-text-3" id="text-3-2">
<p>
We have already committed to checking every platform from every other, so this one is simple: simply see if the x- or y-coordinates match and construct the activity in both directions, because we only look ahead.
In the implementation I make the equivalent check if either &Delta; x or &Delta; y is 0, because it seemed a bit faster.
</p>

<p>
This, as above, runs in &Theta;(P<sup>2</sup>) time.
By sorting the platforms by x- and y-coordinate separately, all platforms on vertical and horizontal lines, respectively, would be next to each other.
Then one could iterate through the array and construct the activities in O(P<sup>2</sup>) time worst-case, but &Omega;(Plog P) in the best.
</p>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5"><span class="section-number-3">3.3</span> Human Cannon (A2, blue)</h3>
<div class="outline-text-3" id="text-3-3">
<p>
This becomes slightly more complicated because we only look ahead.
</p>

<p>
I maintain two arrays of length P of platforms and distances respectively.
These are indexed by platform number, so the platform furthest away from platform x encountered so far is found at index x in the first array and the distance in the second.
Then every time we calculate the distance between two platforms, look up both platforms in the arrays and see if one needs updating.
When finished with a platform, draw the activity to the platform in the array.
</p>

<p>
The arrays are needed to solve the following problem:
Consider platform 5 in figure <a href="#orgparagraph3">3</a>.
From 5 we will only look at platforms 7 and 6 because we look ahead, so at platform 0 we need to have remembered that 0 is furthest away so far.
</p>

<p>
Because \sqrt{x}&gt; \sqrt{y} implies x&gt; y, I save the square root and compare manhattan distances instead of euclidean.
</p>

<p>
Again I have chosen the straight-forward &Theta;(P<sup>2</sup>) solution, because the A3-activities dominate regardless, but this is actually solvable in O(Plog P) time.
See <a href="http://www.researchgate.net/publication/220115912_An_O(n_log_n)_algorithm_for_the_all-farthest-segments_problem_for_a_planar_set_of_points">An O(n log n) algorithm for the all-farthest-segments problem for a planar set of points</a>.
</p>

<p>
If I could construct the A3-activities faster, these optimizations would be worth doing.
</p>
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6"><span class="section-number-3">3.4</span> EOF Wormhole (A4, orange)</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Here we just construct an A4-activity from each platform to the last one.
</p>

<p>
This of course takes linear time in the number of platforms.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline17" class="outline-2">
<h2 id="orgheadline17"><span class="section-number-2">4</span> Annotated Code</h2>
<div class="outline-text-2" id="text-4">
<p>
After setting up the graph as described above, it really is just a matter of running Edmonds-Karp or another maximum flow algorithm.
I won't go into details with that, instead I have annotated the source code below, so the above discussion becomes a bit more concrete.
</p>

<p>
I've chosen to include the entirety of the code, just under 500 lines, so feel free to skip a section or two.
The code is almost exactly equal to the one I submitted to the competition, only small non-functional edits have been made.
</p>

<p>
The indentation should be correct even though the code has been split up by my commentary, so I hope it's readable.
</p>
</div>

<div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8"><span class="section-number-3">4.1</span> Includes</h3>
<div class="outline-text-3" id="text-4-1">
<p>
CodeJudge is the online system used, among other things, to test the submissions.
First I disable assertions when running on CodeJudge for performance.
Also, it's a Linux box so the <code>time</code> header has a different path than on my Mac.
This checking should really be more robust (ie. using <code>__APPLE__</code>) but it doesn't really matter.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #268bd2;">#ifdef</span> CODEJUDGE
<span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">NDEBUG</span>
<span style="color: #268bd2;">#endif</span>

<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;stdlib.h&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;stdbool.h&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;assert.h&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;limits.h&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;stdint.h&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;string.h&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;math.h&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;stdio.h&gt;</span>

<span style="color: #268bd2;">#ifdef</span> CODEJUDGE
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;time.h&gt;</span>
<span style="color: #268bd2;">#else</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;sys/time.h&gt;</span>
<span style="color: #268bd2;">#endif</span>
</pre>
</div>

<p>
The definitions are, in order: the maximum number of characters on a given line of input rounded to a nice number, when to switch from quicksort to insertion sort, and how many vertices are in the flow network per platform (see above).
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">MAX_LINE</span> <span style="color: #268bd2; font-weight: bold;">42</span>
<span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">SORT_CUTOFF</span> <span style="color: #268bd2; font-weight: bold;">16</span>
<span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">VERTEX_FACTOR</span> <span style="color: #268bd2; font-weight: bold;">5</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9"><span class="section-number-3">4.2</span> Structs</h3>
<div class="outline-text-3" id="text-4-2">
<p>
What's nice about C is that data and functionality is separated.
These five types will be used throughout the rest of the program.
</p>

<p>
One thing to note is the bit-flag for an <code>Edge</code> to see if it points forwards or backwards.
We can afford this, since capacity is at most 100.000 by the problem description which fits easily in 31 bits and I've found this to be the easiest way to represent the residual flow network.
</p>

<p>
Also note that I'm using adjacency tables for my graph representation instead of linked lists, to improve cache performance.
It made a surprising difference for the breadth-first search.
</p>

<p>
<code>x, y</code> for a <code>Platform</code> is <code>int32_t</code> even though they're never negative, to save a cast later.
</p>

<p>
Some of these members could actually be marked <code>const</code> according to both Clang and myself, but then GCC won't compile it&#x2026;
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #93a1a1;">/*</span>
<span style="color: #93a1a1;"> * STRUCTS</span>
<span style="color: #93a1a1;"> </span><span style="color: #93a1a1;">*/</span>

<span style="color: #859900; font-weight: bold;">typedef</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">Edge</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">from</span>;
  <span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">to</span>;
  <span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">flow</span>;
  <span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">capacity</span> : <span style="color: #268bd2; font-weight: bold;">31</span>;
  <span style="color: #b58900;">bool</span> <span style="color: #268bd2;">forwards</span> : <span style="color: #268bd2; font-weight: bold;">1</span>;
<span style="color: #2aa198;">}</span> <span style="color: #b58900;">Edge</span>;

<span style="color: #859900; font-weight: bold;">typedef</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">Vertex</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900;">Edge</span> * <span style="color: #268bd2;">parent_edge</span>;
  <span style="color: #b58900;">Edge</span> * <span style="color: #268bd2;">edge_list</span>;
  <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">capacity</span>;
  <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">size</span>;
<span style="color: #2aa198;">}</span> <span style="color: #b58900;">Vertex</span>;

<span style="color: #859900; font-weight: bold;">typedef</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900;">Vertex</span> * <span style="color: #268bd2;">vertices</span>;
  <span style="color: #b58900;">size_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">size</span>;
<span style="color: #2aa198;">}</span> <span style="color: #b58900;">Graph</span>;

<span style="color: #859900; font-weight: bold;">typedef</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900;">uint32_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">data</span>;
  <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">head</span>;
  <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">tail</span>;
  <span style="color: #b58900;">size_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">capacity</span>;
<span style="color: #2aa198;">}</span> <span style="color: #b58900;">Queue</span>;

<span style="color: #859900; font-weight: bold;">typedef</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900;">int32_t</span> <span style="color: #268bd2;">x</span>, <span style="color: #268bd2;">y</span>;
  <span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">n</span>, <span style="color: #268bd2;">a1</span>, <span style="color: #268bd2;">a2</span>, <span style="color: #268bd2;">a3</span>, <span style="color: #268bd2;">a4</span>;
<span style="color: #2aa198;">}</span> <span style="color: #b58900;">Platform</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10"><span class="section-number-3">4.3</span> Prototypes</h3>
<div class="outline-text-3" id="text-4-3">
<p>
I like to mark as many things <code>const</code> as possible.
That way, I opt in to mutation and get an error if I change anything accidentally.
</p>

<p>
The <code>_alloc</code> functions ended up taking pointers to pre-allocated memory instead of allocating themselves.
This makes it easier to control the allocation and I get to share some of it between the graph setup and flow algorithm, but makes the name a bit odd.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #93a1a1;">/*</span>
<span style="color: #93a1a1;"> * PROTOTYPES</span>
<span style="color: #93a1a1;"> </span><span style="color: #93a1a1;">*/</span>

<span style="color: #b58900;">Graph</span> <span style="color: #268bd2;">graph_alloc</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Vertex</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">vertices</span>, <span style="color: #b58900;">size_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">V</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">void</span> <span style="color: #268bd2;">graph_free</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Graph</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">G</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">void</span> <span style="color: #268bd2;">insert_edge</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Graph</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">G</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">from</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">to</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">capacity</span>, <span style="color: #b58900;">bool</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">forwards</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900;">Queue</span> <span style="color: #268bd2;">queue_alloc</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">uint32_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">data</span>, <span style="color: #b58900;">size_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">capacity</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">void</span> <span style="color: #268bd2;">enqueue</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Queue</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">Q</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">x</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">dequeue</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Queue</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">Q</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">bool</span> <span style="color: #268bd2;">queue_is_empty</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Queue</span> <span style="color: #859900; font-weight: bold;">const</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">Q</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">void</span> <span style="color: #268bd2;">queue_clear</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Queue</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">Q</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">min</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">a</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">b</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">max</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">a</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">b</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900;">void</span> <span style="color: #268bd2;">insert_flow_edge</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Graph</span> * <span style="color: #859900; font-weight: bold;">const</span>  <span style="color: #268bd2;">G</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">from</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">capacity</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">edmonds_karp</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Graph</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">G</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">source</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">sink</span>, <span style="color: #b58900;">uint32_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">queue_data</span>, <span style="color: #b58900;">uint8_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">marked</span>, <span style="color: #b58900;">uint32_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">caps</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900;">void</span> <span style="color: #268bd2;">swap_platform</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">a</span>, <span style="color: #b58900;">Platform</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">b</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">void</span> <span style="color: #268bd2;">quicksort</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">xs</span>, <span style="color: #b58900;">int</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">lo</span>, <span style="color: #b58900;">int</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">hi</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">partition</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">xs</span>, <span style="color: #b58900;">int</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">lo</span>, <span style="color: #b58900;">int</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">hi</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">bool</span> <span style="color: #268bd2;">less</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">a</span>, <span style="color: #b58900;">Platform</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">b</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">void</span> <span style="color: #268bd2;">insertion_sort</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">xs</span>, <span style="color: #b58900;">size_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">len</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">next_prime</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">a</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">bool</span> <span style="color: #268bd2;">update_slope_count</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">uint32_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">slopes</span>, <span style="color: #b58900;">uint8_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">counts</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">slopes_len</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">key</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11"><span class="section-number-3">4.4</span> Graph</h3>
<div class="outline-text-3" id="text-4-4">
<p>
The initial capacity for the adjacency tables is 64.
This is found experimentally to be the fastest and doesn't seem excessive in terms of memory use.
</p>

<p>
Inserting an edge is really easy with <code>realloc</code>, insert it, check if the size is equal to the capacity and if so double the capacity and reallocate.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #93a1a1;">/*</span>
<span style="color: #93a1a1;"> * GRAPH</span>
<span style="color: #93a1a1;"> </span><span style="color: #93a1a1;">*/</span>

<span style="color: #b58900;">Graph</span> <span style="color: #268bd2;">graph_alloc</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Vertex</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">vertices</span>, <span style="color: #b58900;">size_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">V</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">i</span> = <span style="color: #268bd2; font-weight: bold;">0</span>; i &lt; V; i++<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #b58900;">Edge</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">edge_list</span> = malloc<span style="color: #268bd2;">(</span><span style="color: #268bd2; font-weight: bold;">64</span> * <span style="color: #859900; font-weight: bold;">sizeof</span> *edge_list<span style="color: #268bd2;">)</span>;
    vertices<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span> = <span style="color: #268bd2;">(</span>Vertex<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>.edge_list = edge_list, .size = <span style="color: #268bd2; font-weight: bold;">0</span>, .capacity = <span style="color: #268bd2; font-weight: bold;">64</span>, .parent_edge = <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #268bd2;">}</span>;
  <span style="color: #b58900;">}</span>

  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900;">(</span>Graph<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>.vertices = vertices, .size = V<span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">void</span> <span style="color: #268bd2;">graph_free</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Graph</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">G</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  assert<span style="color: #b58900;">(</span>G != <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #b58900;">)</span>;
  <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">i</span> = <span style="color: #268bd2; font-weight: bold;">0</span>; i &lt; G-&gt;size; i++<span style="color: #b58900;">)</span>
    free<span style="color: #b58900;">(</span>G-&gt;vertices<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span>.edge_list<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">void</span> <span style="color: #268bd2;">insert_edge</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Graph</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">G</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">from</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">to</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">capacity</span>, <span style="color: #b58900;">bool</span> <span style="color: #268bd2;">forwards</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  assert<span style="color: #b58900;">(</span>G != <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #b58900;">)</span>;
  <span style="color: #b58900;">Vertex</span> * <span style="color: #268bd2;">v</span> = &amp;G-&gt;vertices<span style="color: #b58900;">[</span>from<span style="color: #b58900;">]</span>;

  v-&gt;edge_list<span style="color: #b58900;">[</span>v-&gt;size++<span style="color: #b58900;">]</span> = <span style="color: #b58900;">(</span>Edge<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>.from = from, .to = to, .flow = <span style="color: #268bd2; font-weight: bold;">0</span>, .capacity = capacity, .forwards = forwards<span style="color: #b58900;">}</span>;

  <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>v-&gt;size == v-&gt;capacity<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    v-&gt;capacity *= <span style="color: #268bd2; font-weight: bold;">2</span>;
    v-&gt;edge_list = realloc<span style="color: #268bd2;">(</span>v-&gt;edge_list, v-&gt;capacity * <span style="color: #859900; font-weight: bold;">sizeof</span> *v-&gt;edge_list<span style="color: #268bd2;">)</span>;
  <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12"><span class="section-number-3">4.5</span> Queue</h3>
<div class="outline-text-3" id="text-4-5">
<p>
This queue is taken straight from CLRS.
It's used for the breadth-first search in Edmonds-Karp where we know the upper bound, 5P, of vertices enqueued and we know this doesn't get too large.
So we just pre-allocate a big enough chunk of memory and keep two indices into it: one for the head and one for the tail.
Enqueuing and dequeuing is just a read/write and a modulo operation and more importantly, we can clear the queue in constant time by just setting these to 0.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #93a1a1;">/*</span>
<span style="color: #93a1a1;"> * QUEUE</span>
<span style="color: #93a1a1;"> </span><span style="color: #93a1a1;">*/</span>

<span style="color: #b58900;">Queue</span> <span style="color: #268bd2;">queue_alloc</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">uint32_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">data</span>, <span style="color: #b58900;">size_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">capacity</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900;">(</span>Queue<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>.capacity = capacity, .data = data, .head = <span style="color: #268bd2; font-weight: bold;">0</span>, .tail = <span style="color: #268bd2; font-weight: bold;">0</span><span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">void</span> <span style="color: #268bd2;">enqueue</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Queue</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">Q</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">x</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  assert<span style="color: #b58900;">(</span>Q != <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #b58900;">)</span>;
  assert<span style="color: #b58900;">(</span>Q-&gt;head != <span style="color: #268bd2;">(</span>Q-&gt;tail+<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #268bd2;">)</span> % Q-&gt;capacity<span style="color: #b58900;">)</span>;

  Q-&gt;data<span style="color: #b58900;">[</span>Q-&gt;tail<span style="color: #b58900;">]</span> = x;
  Q-&gt;tail = <span style="color: #b58900;">(</span>Q-&gt;tail + <span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #b58900;">)</span> % Q-&gt;capacity;
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">dequeue</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Queue</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">Q</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  assert<span style="color: #b58900;">(</span>Q != <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #b58900;">)</span>;
  assert<span style="color: #b58900;">(</span><span style="color: #b58900; font-weight: bold;">!</span>queue_is_empty<span style="color: #268bd2;">(</span>Q<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>;

  <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">x</span> = Q-&gt;data<span style="color: #b58900;">[</span>Q-&gt;head<span style="color: #b58900;">]</span>;
  Q-&gt;head = <span style="color: #b58900;">(</span>Q-&gt;head+<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #b58900;">)</span> % Q-&gt;capacity;

  <span style="color: #859900; font-weight: bold;">return</span> x;
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">bool</span> <span style="color: #268bd2;">queue_is_empty</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Queue</span> <span style="color: #859900; font-weight: bold;">const</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">Q</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  assert<span style="color: #b58900;">(</span>Q != <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #b58900;">)</span>;
  <span style="color: #859900; font-weight: bold;">return</span> Q-&gt;head == Q-&gt;tail;
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">void</span> <span style="color: #268bd2;">queue_clear</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Queue</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">Q</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  Q-&gt;head = <span style="color: #268bd2; font-weight: bold;">0</span>;
  Q-&gt;tail = <span style="color: #268bd2; font-weight: bold;">0</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13"><span class="section-number-3">4.6</span> Flow</h3>
<div class="outline-text-3" id="text-4-6">
<p>
Now the Edmonds-Karp algorithm.
First two helper functions; it wouldn't be C if you didn't have to write everything yourself.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #93a1a1;">/*</span>
<span style="color: #93a1a1;"> * FLOW</span>
<span style="color: #93a1a1;"> </span><span style="color: #93a1a1;">*/</span>

<span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">min</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">a</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">b</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>a &lt; b<span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">return</span> a; <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #859900; font-weight: bold;">return</span> b;
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">max</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">a</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">b</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>a &gt; b<span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">return</span> a; <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #859900; font-weight: bold;">return</span> b;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p>
Then the actual algorithm where I have chosen to inline the breadth-first search.
We see how the <code>forwards</code> bit-flag is used to determine which way an edge goes, and thus whether we're adding flow to it or letting some of the flow take a different route.
Again, see Wikipedia for a description of the algorithm.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">edmonds_karp</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Graph</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">G</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">source</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">sink</span>, <span style="color: #b58900;">uint32_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">queue_data</span>, <span style="color: #b58900;">uint8_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">marked</span>, <span style="color: #b58900;">uint32_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">caps</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  assert<span style="color: #b58900;">(</span>G != <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #b58900;">)</span>;

  <span style="color: #b58900;">Edge</span> * <span style="color: #268bd2;">head</span>;
  <span style="color: #b58900;">Queue</span> <span style="color: #268bd2;">q</span> = queue_alloc<span style="color: #b58900;">(</span>queue_data, G-&gt;size<span style="color: #b58900;">)</span>;

  <span style="color: #859900; font-weight: bold;">do</span> <span style="color: #b58900;">{</span>
    queue_clear<span style="color: #268bd2;">(</span>&amp;q<span style="color: #268bd2;">)</span>;
    enqueue<span style="color: #268bd2;">(</span>&amp;q, source<span style="color: #268bd2;">)</span>;
    caps<span style="color: #268bd2;">[</span>source<span style="color: #268bd2;">]</span> = UINT_MAX;
    marked<span style="color: #268bd2;">[</span>source<span style="color: #268bd2;">]</span> = <span style="color: #268bd2; font-weight: bold;">1</span>;
    G-&gt;vertices<span style="color: #268bd2;">[</span>sink<span style="color: #268bd2;">]</span>.parent_edge = <span style="color: #268bd2; font-weight: bold;">NULL</span>;

    <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-weight: bold;">!</span>queue_is_empty<span style="color: #6c71c4;">(</span>&amp;q<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
      <span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">v</span> = dequeue<span style="color: #6c71c4;">(</span>&amp;q<span style="color: #6c71c4;">)</span>;

      <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #6c71c4;">(</span><span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">i</span> = <span style="color: #268bd2; font-weight: bold;">0</span>; i &lt; G-&gt;vertices<span style="color: #859900;">[</span>v<span style="color: #859900;">]</span>.size; i++<span style="color: #6c71c4;">)</span> <span style="color: #6c71c4;">{</span>
        <span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">u</span>;
        <span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">residual</span>;
        <span style="color: #b58900;">Edge</span> * <span style="color: #268bd2;">cur</span> = &amp;G-&gt;vertices<span style="color: #859900;">[</span>v<span style="color: #859900;">]</span>.edge_list<span style="color: #859900;">[</span>i<span style="color: #859900;">]</span>;

        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #859900;">(</span>cur-&gt;forwards<span style="color: #859900;">)</span> <span style="color: #859900;">{</span>
          u = cur-&gt;to;
          residual = cur-&gt;capacity - cur-&gt;flow;
        <span style="color: #859900;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #859900;">{</span>
          u = cur-&gt;from;
          residual = cur-&gt;flow;
        <span style="color: #859900;">}</span>

        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #859900;">(</span>residual &gt; <span style="color: #268bd2; font-weight: bold;">0</span> &amp;&amp; <span style="color: #b58900; font-weight: bold;">!</span>marked<span style="color: #b58900;">[</span>u<span style="color: #b58900;">]</span><span style="color: #859900;">)</span> <span style="color: #859900;">{</span>
          marked<span style="color: #b58900;">[</span>u<span style="color: #b58900;">]</span> = <span style="color: #268bd2; font-weight: bold;">1</span>;
          G-&gt;vertices<span style="color: #b58900;">[</span>u<span style="color: #b58900;">]</span>.parent_edge = cur;
          caps<span style="color: #b58900;">[</span>u<span style="color: #b58900;">]</span> = min<span style="color: #b58900;">(</span>caps<span style="color: #268bd2;">[</span>v<span style="color: #268bd2;">]</span>, residual<span style="color: #b58900;">)</span>;

          <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>u == sink<span style="color: #b58900;">)</span>
            <span style="color: #859900; font-weight: bold;">goto</span> <span style="color: #268bd2; font-weight: bold;">done</span>;

          enqueue<span style="color: #b58900;">(</span>&amp;q, u<span style="color: #b58900;">)</span>;
        <span style="color: #859900;">}</span>
      <span style="color: #6c71c4;">}</span>
    <span style="color: #268bd2;">}</span>

  <span style="color: #268bd2; font-weight: bold;">done</span>:
    head = G-&gt;vertices<span style="color: #268bd2;">[</span>sink<span style="color: #268bd2;">]</span>.parent_edge;

    <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #268bd2;">(</span>head != <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
      <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">idx</span>;

      <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #6c71c4;">(</span>head-&gt;forwards<span style="color: #6c71c4;">)</span> <span style="color: #6c71c4;">{</span>
        head-&gt;flow += caps<span style="color: #859900;">[</span>sink<span style="color: #859900;">]</span>;
        idx = head-&gt;from;
      <span style="color: #6c71c4;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #6c71c4;">{</span>
        head-&gt;flow -= caps<span style="color: #859900;">[</span>sink<span style="color: #859900;">]</span>;
        idx = head-&gt;to;
      <span style="color: #6c71c4;">}</span>

      head = G-&gt;vertices<span style="color: #6c71c4;">[</span>idx<span style="color: #6c71c4;">]</span>.parent_edge;
    <span style="color: #268bd2;">}</span>

    memset<span style="color: #268bd2;">(</span>marked, <span style="color: #268bd2; font-weight: bold;">0</span>, G-&gt;size * <span style="color: #859900; font-weight: bold;">sizeof</span> *marked<span style="color: #268bd2;">)</span>;

  <span style="color: #b58900;">}</span> <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #b58900;">(</span>G-&gt;vertices<span style="color: #268bd2;">[</span>sink<span style="color: #268bd2;">]</span>.parent_edge != <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #b58900;">)</span>;

  <span style="color: #b58900;">int32_t</span> <span style="color: #268bd2;">sum</span> = <span style="color: #268bd2; font-weight: bold;">0</span>;
  <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">i</span> = <span style="color: #268bd2; font-weight: bold;">0</span>; i &lt; G-&gt;vertices<span style="color: #268bd2;">[</span>source<span style="color: #268bd2;">]</span>.size; i++<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #b58900;">Edge</span> <span style="color: #268bd2;">cur</span> = G-&gt;vertices<span style="color: #268bd2;">[</span>source<span style="color: #268bd2;">]</span>.edge_list<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span>;
    sum += cur.forwards ? cur.flow : -cur.flow;
  <span style="color: #b58900;">}</span>

  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900;">(</span><span style="color: #b58900;">uint32_t</span><span style="color: #b58900;">)</span> sum;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p>
Another little helper for adding edges in both directions and avoiding adding useless ones.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #b58900;">void</span> <span style="color: #268bd2;">insert_flow_edge</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Graph</span> * <span style="color: #859900; font-weight: bold;">const</span>  <span style="color: #268bd2;">G</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">from</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">to</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">capacity</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  assert<span style="color: #b58900;">(</span>G != <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #b58900;">)</span>;
  assert<span style="color: #b58900;">(</span>from != to<span style="color: #b58900;">)</span>;

  <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>capacity == <span style="color: #268bd2; font-weight: bold;">0</span><span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">return</span>;

  insert_edge<span style="color: #b58900;">(</span>G, from, to, capacity, <span style="color: #268bd2; font-weight: bold;">true</span><span style="color: #b58900;">)</span>;
  insert_edge<span style="color: #b58900;">(</span>G, to, from, capacity, <span style="color: #268bd2; font-weight: bold;">false</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline14" class="outline-3">
<h3 id="orgheadline14"><span class="section-number-3">4.7</span> Sorting</h3>
<div class="outline-text-3" id="text-4-7">
<p>
I started out sorting a lot more than the one time I do now, so the sorting is optimized more than turned out to be necessary.
</p>

<p>
First we quicksort down to buckets of <code>SORT_CUTOFF</code>, 16, and then a single insertion sort is run over the entire array to put these buckets into order.
The asymptotic running time is the same, but because insertion sort has lower constants, this is faster.
</p>

<p>
I'm using the Hoare partitioning scheme as described by <a href="http://algs4.cs.princeton.edu/23quicksort/">Sedgewick and Wayne</a>.
The code is almost an exact replica of <a href="http://algs4.cs.princeton.edu/23quicksort/Quick.java.html">their implementation in Java</a>.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #93a1a1;">/*</span>
<span style="color: #93a1a1;"> * SORTING</span>
<span style="color: #93a1a1;"> </span><span style="color: #93a1a1;">*/</span>

<span style="color: #b58900;">void</span> <span style="color: #268bd2;">swap_platform</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> * <span style="color: #268bd2;">a</span>, <span style="color: #b58900;">Platform</span> * <span style="color: #268bd2;">b</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900;">Platform</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">t</span> = *a;
  *a = *b;
  *b = t;
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">bool</span> <span style="color: #268bd2;">less</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">a</span>, <span style="color: #b58900;">Platform</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">b</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #859900; font-weight: bold;">return</span> a.x &lt; b.x || <span style="color: #b58900;">(</span>a.x == b.x &amp;&amp; a.y &lt; b.y<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">partition</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">xs</span>, <span style="color: #b58900;">int</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">lo</span>, <span style="color: #b58900;">int</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">hi</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900;">int</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">idx</span> = rand<span style="color: #b58900;">()</span> % <span style="color: #b58900;">(</span>hi-lo+<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #b58900;">)</span> + lo;
  swap_platform<span style="color: #b58900;">(</span>xs+idx, xs+lo<span style="color: #b58900;">)</span>;

  <span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span> = lo;
  <span style="color: #b58900;">int</span> <span style="color: #268bd2;">j</span> = hi + <span style="color: #268bd2; font-weight: bold;">1</span>;
  <span style="color: #b58900;">Platform</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">x</span> = xs<span style="color: #b58900;">[</span>lo<span style="color: #b58900;">]</span>;

  <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">true</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #268bd2;">(</span>less<span style="color: #6c71c4;">(</span>xs<span style="color: #859900;">[</span>++i<span style="color: #859900;">]</span>, x<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>
      <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>i == hi<span style="color: #268bd2;">)</span> <span style="color: #859900; font-weight: bold;">break</span>;

    <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #268bd2;">(</span>less<span style="color: #6c71c4;">(</span>x, xs<span style="color: #859900;">[</span>--j<span style="color: #859900;">]</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>
      <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>j == lo<span style="color: #268bd2;">)</span> <span style="color: #859900; font-weight: bold;">break</span>;

    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>i &gt;= j<span style="color: #268bd2;">)</span> <span style="color: #859900; font-weight: bold;">break</span>;

    swap_platform<span style="color: #268bd2;">(</span>xs+i, xs+j<span style="color: #268bd2;">)</span>;
  <span style="color: #b58900;">}</span>

  swap_platform<span style="color: #b58900;">(</span>xs+lo, xs+j<span style="color: #b58900;">)</span>;

  <span style="color: #859900; font-weight: bold;">return</span> j;
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">void</span> <span style="color: #268bd2;">quicksort</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">xs</span>, <span style="color: #b58900;">int</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">lo</span>, <span style="color: #b58900;">int</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">hi</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>hi - lo &gt; SORT_CUTOFF<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #b58900;">int</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">p</span> = partition<span style="color: #268bd2;">(</span>xs, lo, hi<span style="color: #268bd2;">)</span>;
    quicksort<span style="color: #268bd2;">(</span>xs, lo, p-<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #268bd2;">)</span>;
    quicksort<span style="color: #268bd2;">(</span>xs, p+<span style="color: #268bd2; font-weight: bold;">1</span>, hi<span style="color: #268bd2;">)</span>;
  <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">void</span> <span style="color: #268bd2;">insertion_sort</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">xs</span>, <span style="color: #b58900;">size_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">len</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">i</span> = <span style="color: #268bd2; font-weight: bold;">1</span>; i &lt; len; i++<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #b58900;">Platform</span> <span style="color: #268bd2;">x</span> = xs<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span>;
    <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">j</span> = i;

    <span style="color: #859900; font-weight: bold;">while</span><span style="color: #268bd2;">(</span>j &gt; <span style="color: #268bd2; font-weight: bold;">0</span> &amp;&amp; less<span style="color: #6c71c4;">(</span>x, xs<span style="color: #859900;">[</span>j-<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #859900;">]</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
      xs<span style="color: #6c71c4;">[</span>j<span style="color: #6c71c4;">]</span> = xs<span style="color: #6c71c4;">[</span>j-<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #6c71c4;">]</span>;
      j--;
    <span style="color: #268bd2;">}</span>

    xs<span style="color: #268bd2;">[</span>j<span style="color: #268bd2;">]</span> = x;
  <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline15" class="outline-3">
<h3 id="orgheadline15"><span class="section-number-3">4.8</span> Hashing</h3>
<div class="outline-text-3" id="text-4-8">
<p>
For the hash table I'm just using a simple linear probing technique.
The slopes turn out to be really well distributed and I'm using a load factor of at most \frac15, so clustering is minimal and this turns out to work nicely.
</p>

<p>
Because the counts are stored as single byte we don't want to increment it unnecessarily and risk an overflow.
Fortunately the compiler seems to optimize the very straight-forward code really well.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #93a1a1;">/*</span>
<span style="color: #93a1a1;"> * HASHING</span>
<span style="color: #93a1a1;"> </span><span style="color: #93a1a1;">*/</span>

<span style="color: #b58900;">bool</span> <span style="color: #268bd2;">update_slope_count</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">uint32_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">slopes</span>, <span style="color: #b58900;">uint8_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">counts</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">slopes_len</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">key</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  assert<span style="color: #b58900;">(</span>slopes != <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #b58900;">)</span>;

  <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">idx</span> = key % slopes_len;; idx++, idx %= slopes_len<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>counts<span style="color: #6c71c4;">[</span>idx<span style="color: #6c71c4;">]</span> == <span style="color: #268bd2; font-weight: bold;">0</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
      counts<span style="color: #6c71c4;">[</span>idx<span style="color: #6c71c4;">]</span> = <span style="color: #268bd2; font-weight: bold;">1</span>;
      slopes<span style="color: #6c71c4;">[</span>idx<span style="color: #6c71c4;">]</span> = key;
      <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>;
    <span style="color: #268bd2;">}</span>

    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>slopes<span style="color: #6c71c4;">[</span>idx<span style="color: #6c71c4;">]</span> == key<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
      <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #6c71c4;">(</span>counts<span style="color: #859900;">[</span>idx<span style="color: #859900;">]</span> &gt;= <span style="color: #268bd2; font-weight: bold;">2</span><span style="color: #6c71c4;">)</span> <span style="color: #6c71c4;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span>;
      <span style="color: #6c71c4;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #6c71c4;">{</span>
        counts<span style="color: #859900;">[</span>idx<span style="color: #859900;">]</span>++;
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>;
      <span style="color: #6c71c4;">}</span>
    <span style="color: #268bd2;">}</span>
  <span style="color: #b58900;">}</span>

  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p>
Because we're hashing so much, it's worth spending a tiny amount of time finding a prime to hash against for better distribution.
</p>

<div class="org-src-container">

<pre class="src src-c">  <span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">next_prime</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">a</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">x</span> = a;; x++<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
      <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>x % <span style="color: #268bd2; font-weight: bold;">2</span> == <span style="color: #268bd2; font-weight: bold;">0</span><span style="color: #268bd2;">)</span> <span style="color: #859900; font-weight: bold;">continue</span>;
      <span style="color: #b58900;">bool</span> <span style="color: #268bd2;">is_prime</span> = <span style="color: #268bd2; font-weight: bold;">true</span>;
      <span style="color: #b58900;">double</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">limit</span> = sqrt<span style="color: #268bd2;">(</span>x<span style="color: #268bd2;">)</span>;
      <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #268bd2;">(</span><span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">i</span> = <span style="color: #268bd2; font-weight: bold;">3</span>; i &lt;= limit; i += <span style="color: #268bd2; font-weight: bold;">2</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #6c71c4;">(</span>x % i == <span style="color: #268bd2; font-weight: bold;">0</span><span style="color: #6c71c4;">)</span> <span style="color: #6c71c4;">{</span>
          is_prime = <span style="color: #268bd2; font-weight: bold;">false</span>;
          <span style="color: #859900; font-weight: bold;">break</span>;
        <span style="color: #6c71c4;">}</span>
      <span style="color: #268bd2;">}</span>
      <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>is_prime<span style="color: #268bd2;">)</span> <span style="color: #859900; font-weight: bold;">return</span> x;
    <span style="color: #b58900;">}</span>
  <span style="color: #2aa198;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline16" class="outline-3">
<h3 id="orgheadline16"><span class="section-number-3">4.9</span> Main</h3>
<div class="outline-text-3" id="text-4-9">
<p>
Finally the main function.
There's some benchmarking stuff in there behind the <code>ifndef</code>.
</p>

<p>
The random number generator is seeded for the quicksort, which uses a random pivot.
</p>

<p>
Then I do all the allocation aside from the adjacency lists up front.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #93a1a1;">/*</span>
<span style="color: #93a1a1;"> * MAIN</span>
<span style="color: #93a1a1;"> </span><span style="color: #93a1a1;">*/</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
<span style="color: #268bd2;">#if</span><span style="color: #268bd2; font-weight: bold;">n</span><span style="color: #268bd2;">def</span> CODEJUDGE
  <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">timeval</span> <span style="color: #268bd2;">t1</span>, <span style="color: #268bd2;">t2</span>, <span style="color: #268bd2;">t3</span>, <span style="color: #268bd2;">t4</span>, <span style="color: #268bd2;">t5</span>;
  gettimeofday<span style="color: #b58900;">(</span>&amp;t1, <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #b58900;">)</span>;
<span style="color: #268bd2;">#endif</span>

  srand<span style="color: #b58900;">(</span><span style="color: #268bd2;">(</span><span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">int</span><span style="color: #268bd2;">)</span> time<span style="color: #268bd2;">(</span><span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>;

  <span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">P</span>;
  <span style="color: #b58900;">char</span> <span style="color: #268bd2;">line</span><span style="color: #b58900;">[</span>MAX_LINE<span style="color: #b58900;">]</span>;

  fgets<span style="color: #b58900;">(</span>line, MAX_LINE, stdin<span style="color: #b58900;">)</span>;
  sscanf<span style="color: #b58900;">(</span>line, <span style="color: #2aa198;">"%d"</span>, &amp;P<span style="color: #b58900;">)</span>;

  <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">n_slopes</span> = next_prime<span style="color: #b58900;">(</span>VERTEX_FACTOR*P<span style="color: #b58900;">)</span>;

  <span style="color: #b58900;">Platform</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ps</span> = malloc<span style="color: #b58900;">(</span><span style="color: #b58900;">P</span> * <span style="color: #859900; font-weight: bold;">sizeof</span> *ps<span style="color: #b58900;">)</span>;
  <span style="color: #b58900;">uint32_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">furthest</span> = calloc<span style="color: #b58900;">(</span>P, <span style="color: #859900; font-weight: bold;">sizeof</span> *furthest<span style="color: #b58900;">)</span>;
  <span style="color: #b58900;">int64_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">furthest_dist</span> = calloc<span style="color: #b58900;">(</span>P, <span style="color: #859900; font-weight: bold;">sizeof</span> *furthest_dist<span style="color: #b58900;">)</span>;
  <span style="color: #b58900;">Vertex</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">vertices</span> = malloc<span style="color: #b58900;">(</span>VERTEX_FACTOR*P * <span style="color: #859900; font-weight: bold;">sizeof</span> *vertices<span style="color: #b58900;">)</span>;
  <span style="color: #b58900;">uint32_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">slopes</span> = malloc<span style="color: #b58900;">(</span><span style="color: #b58900;">n_slopes</span> * <span style="color: #859900; font-weight: bold;">sizeof</span> *slopes<span style="color: #b58900;">)</span>;
  <span style="color: #b58900;">uint8_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">counts</span> = calloc<span style="color: #b58900;">(</span>n_slopes, <span style="color: #859900; font-weight: bold;">sizeof</span> *counts<span style="color: #b58900;">)</span>;
  <span style="color: #b58900;">uint32_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">caps</span> = malloc<span style="color: #b58900;">(</span>VERTEX_FACTOR*P * <span style="color: #859900; font-weight: bold;">sizeof</span> *caps<span style="color: #b58900;">)</span>;

  <span style="color: #b58900;">Graph</span> <span style="color: #268bd2;">G</span> = graph_alloc<span style="color: #b58900;">(</span>vertices, VERTEX_FACTOR*P<span style="color: #b58900;">)</span>;
</pre>
</div>

<p>
Read in the input.
</p>

<div class="org-src-container">

<pre class="src src-c">  <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">i</span> = <span style="color: #268bd2; font-weight: bold;">0</span>; i &lt; P; i++<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    fgets<span style="color: #b58900;">(</span>line, MAX_LINE, stdin<span style="color: #b58900;">)</span>;
    sscanf<span style="color: #b58900;">(</span>line, <span style="color: #2aa198;">"%d %d %u %u %u %u"</span>, &amp;ps<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span>.x, &amp;ps<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span>.y, &amp;ps<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span>.a1, &amp;ps<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span>.a2, &amp;ps<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span>.a3, &amp;ps<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span>.a4<span style="color: #b58900;">)</span>;
    ps<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span>.n = i;
  <span style="color: #2aa198;">}</span>

<span style="color: #268bd2;">#if</span><span style="color: #268bd2; font-weight: bold;">n</span><span style="color: #268bd2;">def</span> CODEJUDGE
  gettimeofday<span style="color: #2aa198;">(</span>&amp;t2, <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #2aa198;">)</span>;
<span style="color: #268bd2;">#endif</span>
</pre>
</div>

<p>
I love the next two lines.
It's like we really want to make sure the platforms are sorted&#x2026;
This is of course because the quicksort cuts off when reaching buckets of size 16 and leaves these to be sorted by the insertion sort.
It looks redundant, but certainly isn't!
</p>

<div class="org-src-container">

<pre class="src src-c">  quicksort<span style="color: #2aa198;">(</span>ps, <span style="color: #268bd2; font-weight: bold;">0</span>, <span style="color: #b58900;">(</span><span style="color: #b58900;">int</span><span style="color: #b58900;">)</span> P-<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #2aa198;">)</span>;
  insertion_sort<span style="color: #2aa198;">(</span>ps, P<span style="color: #2aa198;">)</span>;

<span style="color: #268bd2;">#if</span><span style="color: #268bd2; font-weight: bold;">n</span><span style="color: #268bd2;">def</span> CODEJUDGE
  gettimeofday<span style="color: #2aa198;">(</span>&amp;t3, <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #2aa198;">)</span>;
<span style="color: #268bd2;">#endif</span>
</pre>
</div>

<p>
Here's the main loop.
First the edges for converting from vertex to edge capacities are inserted according to the schema, and the trivial A4-activities are constructed.
</p>

<div class="org-src-container">

<pre class="src src-c">  <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Vertex schema:</span>
<span style="color: #93a1a1;">   * i: ingoing (original vertex)</span>
<span style="color: #93a1a1;">   * i+1*P: A1</span>
<span style="color: #93a1a1;">   * i+2*P: A2</span>
<span style="color: #93a1a1;">   * i+3*P: A3</span>
<span style="color: #93a1a1;">   * i+4*P: A4</span>
<span style="color: #93a1a1;">   </span><span style="color: #93a1a1;">*/</span>

  <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">i</span> = <span style="color: #268bd2; font-weight: bold;">0</span>; i &lt; P; i++<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">Platform</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">p</span> = ps<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span>;

    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Vertex -&gt; edge capacities</span>
    insert_flow_edge<span style="color: #b58900;">(</span>&amp;G, p.n, p.n+<span style="color: #268bd2; font-weight: bold;">1</span>*P, p.a1<span style="color: #b58900;">)</span>;
    insert_flow_edge<span style="color: #b58900;">(</span>&amp;G, p.n, p.n+<span style="color: #268bd2; font-weight: bold;">2</span>*P, p.a2<span style="color: #b58900;">)</span>;
    insert_flow_edge<span style="color: #b58900;">(</span>&amp;G, p.n, p.n+<span style="color: #268bd2; font-weight: bold;">3</span>*P, p.a3<span style="color: #b58900;">)</span>;
    insert_flow_edge<span style="color: #b58900;">(</span>&amp;G, p.n, p.n+<span style="color: #268bd2; font-weight: bold;">4</span>*P, p.a4<span style="color: #b58900;">)</span>;

    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">A4 (EOF)</span>
    insert_flow_edge<span style="color: #b58900;">(</span>&amp;G, p.n+<span style="color: #268bd2; font-weight: bold;">4</span>*P, P-<span style="color: #268bd2; font-weight: bold;">1</span>, p.a4<span style="color: #b58900;">)</span>;
</pre>
</div>

<p>
Then the inner loop, that looks only at platforms to the left of and above <code>p</code>.
&Delta; x and &Delta; y are calculated for the slope and used to construct A1-activities as well.
</p>

<div class="org-src-container">

<pre class="src src-c">    <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">j</span> = i+<span style="color: #268bd2; font-weight: bold;">1</span>; j &lt; P; j++<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
      <span style="color: #b58900;">Platform</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">q</span> = ps<span style="color: #b58900;">[</span>j<span style="color: #b58900;">]</span>;

      <span style="color: #b58900;">int64_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">dx</span> = p.x - q.x;
      <span style="color: #b58900;">int64_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">dy</span> = p.y - q.y;

      <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">A1 (NEWS)</span>
      <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span><span style="color: #b58900; font-weight: bold;">!</span>dx || <span style="color: #b58900; font-weight: bold;">!</span>dy<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        insert_flow_edge<span style="color: #268bd2;">(</span>&amp;G, p.n+P, q.n, p.a1<span style="color: #268bd2;">)</span>;
        insert_flow_edge<span style="color: #268bd2;">(</span>&amp;G, q.n+P, p.n, q.a1<span style="color: #268bd2;">)</span>;
      <span style="color: #b58900;">}</span>
</pre>
</div>

<p>
I was very curious how to hash floating point values, but simply copying the bits verbatim into an (then arbitrary) unsigned integer works really well.
I use this as the key also instead of the float, because they are identical anyway and this avoids a warning about unsafe comparison of floating point values.
</p>

<div class="org-src-container">

<pre class="src src-c">      <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">A3 (Platform Trampoline)</span>
      <span style="color: #b58900;">float</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">fslope</span> = <span style="color: #2aa198;">(</span><span style="color: #b58900;">float</span><span style="color: #2aa198;">)</span> dy / dx;
      <span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">slope</span>;
      memcpy<span style="color: #2aa198;">(</span>&amp;slope, &amp;fslope, <span style="color: #859900; font-weight: bold;">sizeof</span> slope<span style="color: #2aa198;">)</span>;
      <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #2aa198;">(</span>update_slope_count<span style="color: #b58900;">(</span>slopes, counts, n_slopes, slope<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        insert_flow_edge<span style="color: #b58900;">(</span>&amp;G, p.n+<span style="color: #268bd2; font-weight: bold;">3</span>*P, q.n, p.a3<span style="color: #b58900;">)</span>;
        insert_flow_edge<span style="color: #b58900;">(</span>&amp;G, q.n+<span style="color: #268bd2; font-weight: bold;">3</span>*P, p.n, q.a3<span style="color: #b58900;">)</span>;
      <span style="color: #2aa198;">}</span>
</pre>
</div>

<p>
Then check if either <code>p</code> or <code>q</code> is the new platform furthest away from the other, and construct the A2-activity when the loop exits.
</p>

<p>
Finally clear the counts for the hash table.
This is enough, we don't have to clear <code>slopes</code> as well, so we save a constant factor because the <code>uint8_t</code> array takes up a quarter of the space of <code>slopes</code>.
</p>

<div class="org-src-container">

<pre class="src src-c">      <span style="color: #b58900;">int64_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">dist</span> = dx*dx + dy*dy;
      <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #2aa198;">(</span>dist &gt; furthest_dist<span style="color: #b58900;">[</span>p.n<span style="color: #b58900;">]</span> || <span style="color: #b58900;">(</span>dist == furthest_dist<span style="color: #268bd2;">[</span>p.n<span style="color: #268bd2;">]</span> &amp;&amp; q.n &lt; furthest<span style="color: #268bd2;">[</span>p.n<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        furthest<span style="color: #b58900;">[</span>p.n<span style="color: #b58900;">]</span> = q.n;
        furthest_dist<span style="color: #b58900;">[</span>p.n<span style="color: #b58900;">]</span> = dist;
      <span style="color: #2aa198;">}</span>

      <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #2aa198;">(</span>dist &gt; furthest_dist<span style="color: #b58900;">[</span>q.n<span style="color: #b58900;">]</span> || <span style="color: #b58900;">(</span>dist == furthest_dist<span style="color: #268bd2;">[</span>q.n<span style="color: #268bd2;">]</span> &amp;&amp; p.n &lt; furthest<span style="color: #268bd2;">[</span>q.n<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        furthest<span style="color: #b58900;">[</span>q.n<span style="color: #b58900;">]</span> = p.n;
        furthest_dist<span style="color: #b58900;">[</span>q.n<span style="color: #b58900;">]</span> = dist;
      <span style="color: #2aa198;">}</span>
    <span style="color: #657b83; background-color: #fdf6e3;">}</span>

    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">A2 (Human Cannon)</span>
    insert_flow_edge<span style="color: #657b83; background-color: #fdf6e3;">(</span>&amp;G, p.n+<span style="color: #268bd2; font-weight: bold;">2</span>*P, furthest<span style="color: #2aa198;">[</span>p.n<span style="color: #2aa198;">]</span>, p.a2<span style="color: #657b83; background-color: #fdf6e3;">)</span>;

    memset<span style="color: #657b83; background-color: #fdf6e3;">(</span>counts, <span style="color: #268bd2; font-weight: bold;">0</span>, <span style="color: #b58900;">n_slopes</span> * <span style="color: #859900; font-weight: bold;">sizeof</span> *counts<span style="color: #657b83; background-color: #fdf6e3;">)</span>;
  <span style="color: #657b83; background-color: #fdf6e3;">}</span>

<span style="color: #268bd2;">#if</span><span style="color: #268bd2; font-weight: bold;">n</span><span style="color: #268bd2;">def</span> CODEJUDGE
  gettimeofday<span style="color: #657b83; background-color: #fdf6e3;">(</span>&amp;t4, <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #657b83; background-color: #fdf6e3;">)</span>;
<span style="color: #268bd2;">#endif</span>
</pre>
</div>

<p>
Run the flow algorithm, print the result and free the memory.
Freeing the adjacency tables takes too long because we need to iterate over all the vertices, so I only do that locally.
</p>

<p>
In the end I print some running times for testing.
</p>

<div class="org-src-container">

<pre class="src src-c">  <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">flow</span> = edmonds_karp<span style="color: #2aa198;">(</span>&amp;G, <span style="color: #268bd2; font-weight: bold;">0</span>, P-<span style="color: #268bd2; font-weight: bold;">1</span>, slopes, counts, caps<span style="color: #2aa198;">)</span>;
  printf<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"%u\n"</span>, flow<span style="color: #2aa198;">)</span>;

  free<span style="color: #2aa198;">(</span>ps<span style="color: #2aa198;">)</span>;
  free<span style="color: #2aa198;">(</span>furthest<span style="color: #2aa198;">)</span>;
  free<span style="color: #2aa198;">(</span>furthest_dist<span style="color: #2aa198;">)</span>;
  free<span style="color: #2aa198;">(</span>slopes<span style="color: #2aa198;">)</span>;
  free<span style="color: #2aa198;">(</span>counts<span style="color: #2aa198;">)</span>;
  free<span style="color: #2aa198;">(</span>caps<span style="color: #2aa198;">)</span>;
  free<span style="color: #2aa198;">(</span>vertices<span style="color: #2aa198;">)</span>;

<span style="color: #268bd2;">#if</span><span style="color: #268bd2; font-weight: bold;">n</span><span style="color: #268bd2;">def</span> CODEJUDGE
  gettimeofday<span style="color: #2aa198;">(</span>&amp;t5, <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #2aa198;">)</span>;

  graph_free<span style="color: #2aa198;">(</span>&amp;G<span style="color: #2aa198;">)</span>;

  <span style="color: #b58900;">double</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">input_time</span> = <span style="color: #2aa198;">(</span>t2.tv_sec - t1.tv_sec<span style="color: #2aa198;">)</span> * <span style="color: #268bd2; font-weight: bold;">1000</span>.<span style="color: #268bd2; font-weight: bold;">0</span> + <span style="color: #2aa198;">(</span>t2.tv_usec - t1.tv_usec<span style="color: #2aa198;">)</span> / <span style="color: #268bd2; font-weight: bold;">1000</span>.<span style="color: #268bd2; font-weight: bold;">0</span>;

  <span style="color: #b58900;">double</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">sort_time</span> = <span style="color: #2aa198;">(</span>t3.tv_sec - t2.tv_sec<span style="color: #2aa198;">)</span> * <span style="color: #268bd2; font-weight: bold;">1000</span>.<span style="color: #268bd2; font-weight: bold;">0</span> + <span style="color: #2aa198;">(</span>t3.tv_usec - t2.tv_usec<span style="color: #2aa198;">)</span> / <span style="color: #268bd2; font-weight: bold;">1000</span>.<span style="color: #268bd2; font-weight: bold;">0</span>;

  <span style="color: #b58900;">double</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">setup_time</span> = <span style="color: #2aa198;">(</span>t4.tv_sec - t3.tv_sec<span style="color: #2aa198;">)</span> * <span style="color: #268bd2; font-weight: bold;">1000</span>.<span style="color: #268bd2; font-weight: bold;">0</span> + <span style="color: #2aa198;">(</span>t4.tv_usec - t3.tv_usec<span style="color: #2aa198;">)</span> / <span style="color: #268bd2; font-weight: bold;">1000</span>.<span style="color: #268bd2; font-weight: bold;">0</span>;

  <span style="color: #b58900;">double</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">flow_time</span> = <span style="color: #2aa198;">(</span>t5.tv_sec - t4.tv_sec<span style="color: #2aa198;">)</span> * <span style="color: #268bd2; font-weight: bold;">1000</span>.<span style="color: #268bd2; font-weight: bold;">0</span> + <span style="color: #2aa198;">(</span>t5.tv_usec - t4.tv_usec<span style="color: #2aa198;">)</span> / <span style="color: #268bd2; font-weight: bold;">1000</span>.<span style="color: #268bd2; font-weight: bold;">0</span>;

  <span style="color: #b58900;">double</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">total_time</span> = <span style="color: #2aa198;">(</span>t5.tv_sec - t1.tv_sec<span style="color: #2aa198;">)</span> * <span style="color: #268bd2; font-weight: bold;">1000</span>.<span style="color: #268bd2; font-weight: bold;">0</span> + <span style="color: #2aa198;">(</span>t5.tv_usec - t1.tv_usec<span style="color: #2aa198;">)</span> / <span style="color: #268bd2; font-weight: bold;">1000</span>.<span style="color: #268bd2; font-weight: bold;">0</span>;

  printf<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"INPUT: %6.2f\tSORT: %6.2f\tSETUP: %6.2f\tFLOW: %6.2f\tTOTAL: %6.2f\n"</span>, input_time, sort_time, setup_time, flow_time, total_time<span style="color: #2aa198;">)</span>;
<span style="color: #268bd2;">#endif</span>

  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">0</span>;
<span style="color: #657b83; background-color: #fdf6e3;">}</span>
</pre>
</div>

<p>
And we're done.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline18" class="outline-2">
<h2 id="orgheadline18"><span class="section-number-2">5</span> Sample running times</h2>
<div class="outline-text-2" id="text-5">
<p>
I've included the input size (in parenthesis) and running times for the largest input given, in table <a href="#orgsrcblock2">2</a>, generated by the implementation.
The time taken to solve different inputs of the same size can vary greatly based on how many platforms are on line, their capacities etc.
This is just to get an idea about where the time is spent.
</p>

<div class="org-src-container">
<label class="org-src-name">Running times for the largest inputs in milliseconds</label>
<pre class="src src-text" id="orgsrcblock2">2680 (2000)
INPUT:   2.75 SORT:   0.16  SETUP:  74.03 FLOW:   1.88  TOTAL:  78.82
7632 (4000)
INPUT:   3.50 SORT:   0.46  SETUP: 290.53 FLOW:  21.29  TOTAL: 315.78
199880 (5000)
INPUT:   6.20 SORT:   0.50  SETUP: 208.31 FLOW:   0.26  TOTAL: 215.27
2420 (6000)
INPUT:   8.26 SORT:   0.46  SETUP: 227.51 FLOW:   0.07  TOTAL: 236.30
70404 (8000)
INPUT:   9.81 SORT:   0.70  SETUP: 458.47 FLOW:   0.30  TOTAL: 469.28
</pre>
</div>

<p>
Setup dominates greatly.
</p>
</div>
</div>

<div id="outline-container-orgheadline19" class="outline-2">
<h2 id="orgheadline19"><span class="section-number-2">6</span> License</h2>
<div class="outline-text-2" id="text-6">
<p>
Copyright © 2015 Andreas H. From
</p>

<p>
Distributed under the MIT License.
</p>

<p>
This applies of course only to my code, text and figures, not necessarily anything linked from this page.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara">North, East, West, South</div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara">End-Of-Fun</div></div>


</div>
</div></div>
</body>
</html>
