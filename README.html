<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>The Playground &#x2013; My Optimized Solution</title>
<meta  name="generator" content="Org-mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">The Playground &#x2013; My Optimized Solution</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">1. The Problem</a></li>
<li><a href="#orgheadline2">2. Modeling the Problem</a></li>
<li><a href="#orgheadline7">3. Setting up the Graph</a>
<ul>
<li><a href="#orgheadline3">3.1. NEWS Slide (A1, red)</a></li>
<li><a href="#orgheadline4">3.2. Human Cannon (A2, blue)</a></li>
<li><a href="#orgheadline5">3.3. Platform Trampoline (A3, green)</a></li>
<li><a href="#orgheadline6">3.4. EOF Wormhole (A4, orange)</a></li>
</ul>
</li>
<li><a href="#orgheadline18">4. Annotated Code</a>
<ul>
<li><a href="#orgheadline8">4.1. Includes</a></li>
<li><a href="#orgheadline9">4.2. Structs</a></li>
<li><a href="#orgheadline10">4.3. Prototypes</a></li>
<li><a href="#orgheadline11">4.4. Graph</a></li>
<li><a href="#orgheadline12">4.5. Queue</a></li>
<li><a href="#orgheadline13">4.6. Flow</a></li>
<li><a href="#orgheadline14">4.7. Sorting</a></li>
<li><a href="#orgheadline15">4.8. Hashing</a></li>
<li><a href="#orgheadline16">4.9. Convex Hull</a></li>
<li><a href="#orgheadline17">4.10. Main</a></li>
</ul>
</li>
<li><a href="#orgheadline19">5. Sample running times</a></li>
<li><a href="#orgheadline20">6. License</a></li>
</ul>
</div>
</div>
<p>
This is an informal description of my solution to an internal programming competition in my algorithms and data structures course.
The competition has ended, but at the time of writing winners have not been announced.
I hold second place based on test cases behind an implementation in Python, so this can't be optimal, but not that bad either.
It turns out the first place, which deserves to win, combined setting up the graph and running the flow algorithm.
This way the flow network is constructed lazily and a lot of the work I spend on setting up the expensive A3-activities is saved.
</p>

<p>
The code is a single file and should built easily with both GCC and Clang, I use the following with varying degrees of optimization:
</p>

<pre class="example">
clang -g -O2 -Weverything -std=c11 playground.c -o playground
</pre>

<p>
Unfortunately GitHub doesn't support <a href="http://orgmode.org/">org</a> files fully, so the references don't work.
I hope the it's clear from context what is meant.
</p>

<p>
<a href="https://github.com/andreasfrom/theplayground/tree/4f65b0a7427092997b9cae86aa2c68850bcea8b0">This commit</a> describes the solution I handed in.
In this past week since that, I've made some improvements; it is this improved solution that I will describe below as it also has the benefit of being clearer.
</p>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1"><span class="section-number-2">1</span> The Problem</h2>
<div class="outline-text-2" id="text-1">
<p>
<a href="http://www2.compute.dtu.dk/courses/02110/ThePlayground.pdf">The original  problem statement is available online</a>, I will describe the problem here as well.
</p>

<p>
The program is given a list of platforms on standard input.
I will use the input in listing <a href="#orgsrcblock1">1</a> as a running example.
</p>

<div class="org-src-container">
<label class="org-src-name">Sample input for a problem with 8 platforms</label>
<pre class="src src-text" id="orgsrcblock1">8
0 1 4 0 2 0
2 2 1 2 3 4
4 1 3 1 1 0
4 3 1 0 0 1
6 4 0 0 1 1
9 1 1 0 0 2
9 4 2 0 0 1
9 3 0 0 0 0
</pre>
</div>

<p>
The first line is the number of platforms, \(P\), the next \(P\) lines are the platforms specified by six parameters: x- and y-coordinate and four capacities.
The platforms are implicitly numbered by their position in the input and their positions are distinct.
We're given at least two platforms and at most 100.000.
Both coordinates and capacities are between 0 and 100.000.
The input is illustrated in figure <a href="#orgparagraph1">1</a>.
</p>


<div id="orgparagraph1" class="figure">
<p><img src="./figures/platforms.gif" alt="platforms.gif" />
</p>
<p><span class="figure-number">Figure 1:</span> Visualisation of the sample input</p>
</div>

<p>
Now the thing is that we need to turn this set of platforms into a playground, where you enter at platform 0 and leave from platform \(P-1\).
To do this we will build activities from one platform to another.
There are four kinds of activities, and the four capacities specify how many of each of these can be build from a specific platform.
A trail is a path via a unique set of activities from the start-platform to the end-platform and the task is to maximize the number of trails.
The only output produced is the maximum number of trails; we don't need to print how activities are placed etc.
</p>

<p>
The four different activities are (taken almost verbatim from the problem description):
</p>

<dl class="org-dl">
<dt>NEWS<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> Slide (A1, red)</dt><dd>Can be built from a platform A to any other platform with the same x- or y-coordinate as A. That is, any platform on the same horizontal or vertical line as A.</dd>
<dt>Human Cannon (A2, blue)</dt><dd>Can be built from a platform A to the platform furthest away from A in euclidean distance. In case of a tie, the platform that appeared first in the input wins.</dd>
<dt>Platform Trampoline (A3, green)</dt><dd>Can be built from a platform A to a platform B if there are at least 2 platforms on the line segment between A and B.</dd>
<dt>EOF<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup> Wormhole (A4, orange)</dt><dd>Can be built from any platform directly to the end-platform.</dd>
</dl>

<p>
These are illustrated (without capacities) one by one on figures <a href="#orgparagraph2">2</a>, <a href="#orgparagraph3">3</a>, <a href="#orgparagraph4">4</a>, <a href="#orgparagraph5">5</a> and together on figure <a href="#orgparagraph6">6</a>.
</p>


<div id="orgparagraph2" class="figure">
<p><img src="./figures/a1.gif" alt="a1.gif" />
</p>
<p><span class="figure-number">Figure 2:</span> A1s (same horisontal or vertical line)</p>
</div>

<hr  />


<div id="orgparagraph3" class="figure">
<p><img src="./figures/a2.gif" alt="a2.gif" />
</p>
<p><span class="figure-number">Figure 3:</span> A2s (furthest away)</p>
</div>

<hr  />


<div id="orgparagraph4" class="figure">
<p><img src="./figures/a3.gif" alt="a3.gif" />
</p>
<p><span class="figure-number">Figure 4:</span> A3s (2 or more platforms in-between)</p>
</div>

<hr  />


<div id="orgparagraph5" class="figure">
<p><img src="./figures/a4.gif" alt="a4.gif" />
</p>
<p><span class="figure-number">Figure 5:</span> A4s (end of fun)</p>
</div>

<hr  />


<div id="orgparagraph6" class="figure">
<p><img src="./figures/a1234.gif" alt="a1234.gif" />
</p>
<p><span class="figure-number">Figure 6:</span> All possible activities for the sample input</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2"><span class="section-number-2">2</span> Modeling the Problem</h2>
<div class="outline-text-2" id="text-2">
<p>
We are going to solve this a <a href="https://en.wikipedia.org/wiki/Maximum_flow_problem">maximum flow problem</a>, and I'll assume the reader is familiar with these.
</p>

<p>
If one can follow activities from the start-platform to the end-platform then this corresponds to flow from the source to the sink of the corresponding flow network.
The maximum flow through this network will be the maximum number of trails.
Actually figure <a href="#orgparagraph6">6</a> is exactly this flow network for the sample input, so the correspondence is very direct.
</p>

<p>
The problem with the graph in figure <a href="#orgparagraph6">6</a> is that it has vertex capacities instead of edge capacities that an off-the-shelf maximum flow algorithm expects.
So we need to transform the graph a bit before we can use it.
</p>

<p>
The technique for converting vertex capacities into edge capacities is well known.
The trick is to insert a dummy vertex as in figure <a href="#orgparagraph7">7</a>.
</p>


<div id="orgparagraph7" class="figure">
<p><img src="./figures/vertexcapacity.gif" alt="vertexcapacity.gif" />
</p>
<p><span class="figure-number">Figure 7:</span> Converting a vertex capacity into an edge capacity</p>
</div>

<p>
Any incoming edges will still go to the original vertex, but any outgoing will start at the new vertex instead.
Now to get from the old vertex to the new vertex, the flow must cross an edge with the capacity of the old vertex.
This is equivalent to the vertex having the capacity.
</p>

<p>
So it's easy to convert a graph where vertices have a single capacity to one with edge capacities instead, but our graph has four vertex capacities.
It turns out that we can just insert four dummy vertices instead of one and it works.
Our platforms from figure <a href="#orgparagraph1">1</a> now look like in figure <a href="#orgparagraph8">8</a>.
Notice how the original capacities can now be read off the edges instead of the vertices.
</p>


<div id="orgparagraph8" class="figure">
<p><img src="./figures/edgecaps.gif" alt="edgecaps.gif" />
</p>
<p><span class="figure-number">Figure 8:</span> Our sample platforms with edge capacities</p>
</div>

<p>
It turns out that because only one A2- and A4-activity per platform can be constructed, the dummy vertices for these are redundant: There will just be one edge to it and one from it with the same capacity.
Therefore we only inserts dummmys for A1 and A3 as in <a href="#orgparagraph9">9</a>.
</p>


<div id="orgparagraph9" class="figure">
<p><img src="./figures/edgecaps2.gif" alt="edgecaps2.gif" />
</p>
<p><span class="figure-number">Figure 9:</span> Our sample platforms with only the needed edge capacities</p>
</div>

<p>
The numbering scheme is that the A1-dummy for a platform \(x\) will be numbered \(x+P\) and the A3-dummy numbered \(x+2\cdot P\).
</p>

<p>
The final graph which we can run a standard flow algorithm on is given in figure <a href="#orgparagraph10">10</a>.
The original vertices are black, as are their edges to the new vertices.
The new vertices are colored by the activity whose capacity they match.
Compare this to one of the first four graphs: All edges are still there, they just start at one of the new nodes, but still go to an original node.
</p>


<div id="orgparagraph10" class="figure">
<p><img src="./figures/a1234all.gif" alt="a1234all.gif" />
</p>
<p><span class="figure-number">Figure 10:</span> The final flow network</p>
</div>

<p>
I'm using Edmonds-Karp to find the actual maximum flow, a possible solution with maximum flow 5 can be seen on figure <a href="#orgparagraph11">11</a>.
One trail consists of going from 0 to 4 with an A3-activity, of which 2 can be built from 0, and then from 4 to 7 with an A4-activity.
Another trail uses A1-activities to go from 0 to 5 to 7, and so on.
</p>


<div id="orgparagraph11" class="figure">
<p><img src="./figures/sol.gif" alt="sol.gif" />
</p>
<p><span class="figure-number">Figure 11:</span> One solution to the sample input</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-2">
<h2 id="orgheadline7"><span class="section-number-2">3</span> Setting up the Graph</h2>
<div class="outline-text-2" id="text-3">
<p>
Now we know how to model the problem as something we can solve with an off-the-shelf algorithm, so we just need to set up this flow network efficiently.
</p>

<p>
I will simply discuss constructing an activity between two platforms, so just remember that this actually means from the proper dummy vertex of the first platform to the other platform as described in the previous section.
</p>
</div>

<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3"><span class="section-number-3">3.1</span> NEWS Slide (A1, red)</h3>
<div class="outline-text-3" id="text-3-1">
<p>
We need to construct edges between all platforms sharing either an x- or y-coordinate.
</p>

<p>
By sorting the platforms twice, by x- and y-coordinate separately, all platforms on the same vertical or horizontal line, respectively, will be placed next to each other.
Then we can iterate through the array and construct the activities in \(O(P^2)\) time worst-case, but \(\Omega(P)\) in the best when no platforms share a coordinate (excluding the sorting).
</p>

<p>
We can do this with the following algorithm assuming sorted platforms in the array <code>ps</code> with size <code>P</code>.
</p>

<pre class="example">
for i = 0..P:
    p = ps[i];
    for j = i+1..P while ps[j].x == p.x:
        insert edge from from p to ps[j] and from ps[j] to p
</pre>

<p>
So first we sort by y and run the above for the vertical activities, then by x (with y breaking ties for later) and run the above for the horizontal ones.
We sort twice, but need the sorted array for both A2- and A3-activities, so the work is well spent.
We could use a hash map with direct addressing for a better best case, but that would involve allocating memory for all the platforms again.
Quicksort sorts in-place, which I think is nicer.
</p>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4"><span class="section-number-3">3.2</span> Human Cannon (A2, blue)</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Because the platform furthest away from any other will always be part of the convex hull, it's enough to only check the platforms that are part of the convex hull as candidates for the A2-activity.
This is faster since the amount of platforms in the convex hull is likely to be significantly smaller than \(P\).
Of course the worst case is still \(O(P^2)\) if the platforms are all part of the convex hull.
</p>

<p>
Constructing the convex hull can be done in linear time given sorted points and we can take advantage of this, because the points were sorted to solve A1-activities.
</p>

<p>
Then for each platform we see which platform on the convex hull is furthest away and construct an A2-activity to that.
</p>

<p>
As a detail \(\sqrt{x}\gt \sqrt{y}\) implies \(x\gt y\), so we can save the square root and compare manhattan instead of euclidean distances.
</p>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5"><span class="section-number-3">3.3</span> Platform Trampoline (A3, green)</h3>
<div class="outline-text-3" id="text-3-3">
<p>
The algorithm for constructing these activities is actually quite simple, but it took me a while to figure it out.
A partial run is animated on figure <a href="#orgparagraph12">12</a>.
</p>

<p>
What we want to do is consider each platform in order.
Then when considering a platform, we want to consider a different one and as efficiently as possible, determine whether it is legal to make an A3-activity between the two.
</p>

<p>
The trick is to look at the platforms, not in the order they're given, but from left to right, and from the bottom up.
The order we sorted them in previously.
And furthermore to only look at platforms to the right and up, when already considering one.
This guarantees that we look at platforms on the same line in order by their distance.
That is, when multiple platforms lie on the same line given an origin platform, we will see the closest one first, then the second-closest etc.
</p>

<p>
The algorithm then becomes
</p>

<ul class="org-ul">
<li>(Sort the platforms by x- then y-coordinate (left to right, bottom up))</li>
<li>Initialize an empty hashtable</li>
<li>For each platform p
<ul class="org-ul">
<li>For each platform q ahead of p in the sorted order
<ul class="org-ul">
<li>Calculate the slope between p and q</li>
<li>Look up the slope in our hash table</li>
<li>If the value associated with the slope is 2 (or more), draw an A3-activity from \(p\) to \(q\) and from q to p</li>
<li>Otherwise, increase the count</li>
</ul></li>
<li>Clear the hash table</li>
</ul></li>
</ul>

<p>
We have to construct the activity in both directions because we only look ahead in the sorted order.
</p>

<p>
Looking at figure <a href="#orgparagraph12">12</a>, the count associated with each slope is noted next to its blue line.
Platforms are marked red when visited but no activity is built and green when one is.
We see that the only platform to which an A3-activity can be built from 0 is 4 as expected.
</p>


<div id="orgparagraph12" class="figure">
<p><img src="./figures/slopes/slopes.gif" alt="slopes.gif" />
</p>
<p><span class="figure-number">Figure 12:</span> Partial run of algorithm for determining valid A3-activities</p>
</div>

<p>
With expected constant time lookup in the hash table, this runs in \(\Theta(P^2)\) time.
That's the best upper bound we can hope for, as there might be upwards of \(P^2\) legal A3-activities; consider the case where all platforms lie on a single line.
Unfortunately this is also the lower bound of the algorithm: we always spend \(O(P^2)\) time, even if no A3-activities can be constructed.
I would love to solve this with a lower bound of \(\Omega(P\log P)\) or something instead, but can't figure out how.
</p>

<p>
This is where my competitors method of constructing these lazily really matters.
</p>
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6"><span class="section-number-3">3.4</span> EOF Wormhole (A4, orange)</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Here we just construct an A4-activity from each platform to the last one.
Also we insert the dummy vertices while we're iterating through the platforms anyway.
</p>

<p>
This of course takes linear time in the number of platforms.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline18" class="outline-2">
<h2 id="orgheadline18"><span class="section-number-2">4</span> Annotated Code</h2>
<div class="outline-text-2" id="text-4">
<p>
After setting up the graph as described above, it really is just a matter of running Edmonds-Karp or another maximum flow algorithm.
I won't go into details with that, instead I have annotated the source code below, so the above discussion becomes a bit more concrete.
</p>

<p>
I've chosen to include the entirety of the code, just under 600 lines, so feel free to skip a section or two.
</p>

<p>
Because the code has been split up by my commentary, the indentation is somewhat lost; I hope it's readable regardless.
If not, the entire source file is included with the repository.
</p>
</div>

<div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8"><span class="section-number-3">4.1</span> Includes</h3>
<div class="outline-text-3" id="text-4-1">
<p>
CodeJudge is the online system used, among other things, to test the submissions.
First I disable assertions when running on CodeJudge for performance.
Also, it's a Linux box so the <code>time</code> header has a different path than on my Mac.
This checking should really be more robust (ie. using <code>__APPLE__</code>) but it doesn't really matter.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #268bd2;">#ifdef</span> CODEJUDGE
<span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">NDEBUG</span>
<span style="color: #268bd2;">#endif</span>

<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;stdlib.h&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;stdbool.h&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;assert.h&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;limits.h&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;stdint.h&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;string.h&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;math.h&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;stdio.h&gt;</span>

<span style="color: #268bd2;">#ifdef</span> CODEJUDGE
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;time.h&gt;</span>
<span style="color: #268bd2;">#else</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;sys/time.h&gt;</span>
<span style="color: #268bd2;">#endif</span>
</pre>
</div>

<p>
The definitions are, in order: the maximum number of characters on a given line of input rounded to a nice number, when to switch from quicksort to insertion sort, and how many vertices are in the flow network per platform (see above).
</p>

<p>
Finally there's a macro for calculating the difference in milliseconds between  two <code>timeval</code> s.
This is used for timing different parts of the code.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">MAX_LINE</span> <span style="color: #268bd2; font-weight: bold;">42</span>
<span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">SORT_CUTOFF</span> <span style="color: #268bd2; font-weight: bold;">16</span>
<span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">VERTEX_FACTOR</span> <span style="color: #268bd2; font-weight: bold;">3</span>

<span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">MS</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">S</span>, <span style="color: #268bd2;">T</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span>T.tv_sec - S.tv_sec<span style="color: #2aa198;">)</span> * <span style="color: #268bd2; font-weight: bold;">1000</span>.<span style="color: #268bd2; font-weight: bold;">0</span> + <span style="color: #2aa198;">(</span>T.tv_usec - S.tv_usec<span style="color: #2aa198;">)</span> / <span style="color: #268bd2; font-weight: bold;">1000</span>.<span style="color: #268bd2; font-weight: bold;">0</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9"><span class="section-number-3">4.2</span> Structs</h3>
<div class="outline-text-3" id="text-4-2">
<p>
What's nice about C is that data and functionality is separated.
These five types will be used throughout the rest of the program.
</p>

<p>
One thing to note is the bit-flag for an <code>Edge</code> to see if it points forwards or backwards.
We can afford this, since capacity is at most 100.000 by the problem description which fits easily in 31 bits and I've found this to be the easiest way to represent the residual flow network.
</p>

<p>
Also note that I'm using adjacency tables for my graph representation instead of linked lists, to improve cache performance.
It made a surprising difference for the breadth-first search.
</p>

<p>
<code>x, y</code> for a <code>Platform</code> is <code>int32_t</code> even though they're never negative, to save a cast later.
</p>

<p>
Some of these members could actually be marked <code>const</code> according to both Clang and myself, but then GCC won't compile it&#x2026;
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #93a1a1;">/*</span>
<span style="color: #93a1a1;"> * STRUCTS</span>
<span style="color: #93a1a1;"> </span><span style="color: #93a1a1;">*/</span>

<span style="color: #859900; font-weight: bold;">typedef</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">Edge</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">from</span>;
  <span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">to</span>;
  <span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">flow</span>;
  <span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">capacity</span> : <span style="color: #268bd2; font-weight: bold;">31</span>;
  <span style="color: #b58900;">bool</span> <span style="color: #268bd2;">forwards</span> : <span style="color: #268bd2; font-weight: bold;">1</span>;
<span style="color: #2aa198;">}</span> <span style="color: #b58900;">Edge</span>;

<span style="color: #859900; font-weight: bold;">typedef</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">Vertex</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900;">Edge</span> * <span style="color: #268bd2;">parent_edge</span>;
  <span style="color: #b58900;">Edge</span> * <span style="color: #268bd2;">edge_list</span>;
  <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">capacity</span>;
  <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">size</span>;
<span style="color: #2aa198;">}</span> <span style="color: #b58900;">Vertex</span>;

<span style="color: #859900; font-weight: bold;">typedef</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900;">Vertex</span> * <span style="color: #268bd2;">vertices</span>;
  <span style="color: #b58900;">size_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">size</span>;
<span style="color: #2aa198;">}</span> <span style="color: #b58900;">Graph</span>;

<span style="color: #859900; font-weight: bold;">typedef</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900;">uint32_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">data</span>;
  <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">head</span>;
  <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">tail</span>;
  <span style="color: #b58900;">size_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">capacity</span>;
<span style="color: #2aa198;">}</span> <span style="color: #b58900;">Queue</span>;

<span style="color: #859900; font-weight: bold;">typedef</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900;">int32_t</span> <span style="color: #268bd2;">x</span>, <span style="color: #268bd2;">y</span>;
  <span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">n</span>, <span style="color: #268bd2;">a1</span>, <span style="color: #268bd2;">a2</span>, <span style="color: #268bd2;">a3</span>, <span style="color: #268bd2;">a4</span>;
<span style="color: #2aa198;">}</span> <span style="color: #b58900;">Platform</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10"><span class="section-number-3">4.3</span> Prototypes</h3>
<div class="outline-text-3" id="text-4-3">
<p>
I like to mark as many things <code>const</code> as possible.
That way, I opt in to mutation and get an error if I change anything accidentally.
</p>

<p>
The <code>_alloc</code> functions ended up taking pointers to pre-allocated memory instead of allocating themselves.
This makes it easier to control the allocation and I get to share some of it between the graph setup and flow algorithm, but makes the name a bit odd.
</p>

<p>
<code>LESS</code> is an abbreviation for a pointer to a function comparing two platforms and specifying which should come first in the sorted order.
Quicksort and insertion sort take this as a parameter, so we can sort by both x and y with the same function definitions.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #93a1a1;">/*</span>
<span style="color: #93a1a1;"> * PROTOTYPES</span>
<span style="color: #93a1a1;"> </span><span style="color: #93a1a1;">*/</span>

<span style="color: #859900; font-weight: bold;">typedef</span> <span style="color: #b58900;">bool</span> <span style="color: #2aa198;">(</span>*<span style="color: #b58900;">LESS</span><span style="color: #2aa198;">)(</span>Platform, Platform<span style="color: #2aa198;">)</span>;

<span style="color: #b58900;">Graph</span> <span style="color: #268bd2;">graph_alloc</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Vertex</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">vertices</span>, <span style="color: #b58900;">size_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">V</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">void</span> <span style="color: #268bd2;">graph_free</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Graph</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">G</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">void</span> <span style="color: #268bd2;">insert_edge</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Graph</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">G</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">from</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">to</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">capacity</span>, <span style="color: #b58900;">bool</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">forwards</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900;">Queue</span> <span style="color: #268bd2;">queue_alloc</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">uint32_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">data</span>, <span style="color: #b58900;">size_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">capacity</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">void</span> <span style="color: #268bd2;">enqueue</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Queue</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">Q</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">x</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">dequeue</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Queue</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">Q</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">bool</span> <span style="color: #268bd2;">queue_is_empty</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Queue</span> <span style="color: #859900; font-weight: bold;">const</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">Q</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">void</span> <span style="color: #268bd2;">queue_clear</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Queue</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">Q</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">min</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">a</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">b</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">max</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">a</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">b</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900;">void</span> <span style="color: #268bd2;">insert_flow_edge</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Graph</span> * <span style="color: #859900; font-weight: bold;">const</span>  <span style="color: #268bd2;">G</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">from</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">capacity</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">edmonds_karp</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Graph</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">G</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">source</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">sink</span>, <span style="color: #b58900;">uint32_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">queue_data</span>, <span style="color: #b58900;">uint8_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">marked</span>, <span style="color: #b58900;">uint32_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">caps</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900;">bool</span> <span style="color: #268bd2;">lessxy</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">a</span>, <span style="color: #b58900;">Platform</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">b</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">bool</span> <span style="color: #268bd2;">lessy</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">a</span>, <span style="color: #b58900;">Platform</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">b</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">void</span> <span style="color: #268bd2;">swap_platform</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">a</span>, <span style="color: #b58900;">Platform</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">b</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">void</span> <span style="color: #268bd2;">quicksort</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">xs</span>, <span style="color: #b58900;">int</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">lo</span>, <span style="color: #b58900;">int</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">hi</span>, <span style="color: #b58900;">LESS</span> <span style="color: #268bd2;">less</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">partition</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">xs</span>, <span style="color: #b58900;">int</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">lo</span>, <span style="color: #b58900;">int</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">hi</span>, <span style="color: #b58900;">LESS</span> <span style="color: #268bd2;">less</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">void</span> <span style="color: #268bd2;">insertion_sort</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">xs</span>, <span style="color: #b58900;">size_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">len</span>, <span style="color: #b58900;">LESS</span> <span style="color: #268bd2;">less</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">void</span> <span style="color: #268bd2;">sort</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ps</span>, <span style="color: #b58900;">size_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">P</span>, <span style="color: #b58900;">LESS</span> <span style="color: #268bd2;">less</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">next_prime</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">a</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">bool</span> <span style="color: #268bd2;">update_slope_count</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">uint32_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">slopes</span>, <span style="color: #b58900;">uint8_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">counts</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">slopes_len</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">key</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">ccw</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> * <span style="color: #268bd2;">p1</span>, <span style="color: #b58900;">Platform</span> * <span style="color: #268bd2;">p2</span>, <span style="color: #b58900;">Platform</span> * <span style="color: #268bd2;">p3</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">void</span> <span style="color: #268bd2;">convex_hull</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> * <span style="color: #268bd2;">points</span>, <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">npoints</span>, <span style="color: #b58900;">Platform</span> ** <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">out_hull</span>, <span style="color: #b58900;">size_t</span> * <span style="color: #268bd2;">out_hullsize</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11"><span class="section-number-3">4.4</span> Graph</h3>
<div class="outline-text-3" id="text-4-4">
<p>
The initial capacity for the adjacency tables is 32.
This is found experimentally to be the fastest and doesn't seem excessive in terms of memory use.
</p>

<p>
Inserting an edge is really easy with <code>realloc</code>, insert it, check if the size is equal to the capacity and if so double the capacity and reallocate.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #93a1a1;">/*</span>
<span style="color: #93a1a1;"> * GRAPH</span>
<span style="color: #93a1a1;"> </span><span style="color: #93a1a1;">*/</span>

<span style="color: #b58900;">Graph</span> <span style="color: #268bd2;">graph_alloc</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Vertex</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">vertices</span>, <span style="color: #b58900;">size_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">V</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">i</span> = <span style="color: #268bd2; font-weight: bold;">0</span>; i &lt; V; i++<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #b58900;">Edge</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">edge_list</span> = malloc<span style="color: #268bd2;">(</span><span style="color: #268bd2; font-weight: bold;">32</span> * <span style="color: #859900; font-weight: bold;">sizeof</span> *edge_list<span style="color: #268bd2;">)</span>;
    vertices<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span> = <span style="color: #268bd2;">(</span>Vertex<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>.edge_list = edge_list, .size = <span style="color: #268bd2; font-weight: bold;">0</span>, .capacity = <span style="color: #268bd2; font-weight: bold;">32</span>, .parent_edge = <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #268bd2;">}</span>;
  <span style="color: #b58900;">}</span>

  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900;">(</span>Graph<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>.vertices = vertices, .size = V<span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">void</span> <span style="color: #268bd2;">graph_free</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Graph</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">G</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  assert<span style="color: #b58900;">(</span>G != <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #b58900;">)</span>;
  <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">i</span> = <span style="color: #268bd2; font-weight: bold;">0</span>; i &lt; G-&gt;size; i++<span style="color: #b58900;">)</span>
    free<span style="color: #b58900;">(</span>G-&gt;vertices<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span>.edge_list<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">void</span> <span style="color: #268bd2;">insert_edge</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Graph</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">G</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">from</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">to</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">capacity</span>, <span style="color: #b58900;">bool</span> <span style="color: #268bd2;">forwards</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  assert<span style="color: #b58900;">(</span>G != <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #b58900;">)</span>;
  <span style="color: #b58900;">Vertex</span> * <span style="color: #268bd2;">v</span> = &amp;G-&gt;vertices<span style="color: #b58900;">[</span>from<span style="color: #b58900;">]</span>;

  v-&gt;edge_list<span style="color: #b58900;">[</span>v-&gt;size++<span style="color: #b58900;">]</span> = <span style="color: #b58900;">(</span>Edge<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>.from = from, .to = to, .flow = <span style="color: #268bd2; font-weight: bold;">0</span>, .capacity = capacity, .forwards = forwards<span style="color: #b58900;">}</span>;

  <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>v-&gt;size == v-&gt;capacity<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    v-&gt;capacity *= <span style="color: #268bd2; font-weight: bold;">2</span>;
    v-&gt;edge_list = realloc<span style="color: #268bd2;">(</span>v-&gt;edge_list, v-&gt;capacity * <span style="color: #859900; font-weight: bold;">sizeof</span> *v-&gt;edge_list<span style="color: #268bd2;">)</span>;
  <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12"><span class="section-number-3">4.5</span> Queue</h3>
<div class="outline-text-3" id="text-4-5">
<p>
This queue is taken straight from CLRS.
It's used for the breadth-first search in Edmonds-Karp where we know the upper bound, 3P, of vertices enqueued and we know this doesn't get too large.
So we just pre-allocate a big enough chunk of memory and keep two indices into it: one for the head and one for the tail.
Enqueuing and dequeuing is just a read/write and a modulo operation and more importantly, we can clear the queue in constant time by just setting these to 0.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #93a1a1;">/*</span>
<span style="color: #93a1a1;"> * QUEUE</span>
<span style="color: #93a1a1;"> </span><span style="color: #93a1a1;">*/</span>

<span style="color: #b58900;">Queue</span> <span style="color: #268bd2;">queue_alloc</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">uint32_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">data</span>, <span style="color: #b58900;">size_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">capacity</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900;">(</span>Queue<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>.capacity = capacity, .data = data, .head = <span style="color: #268bd2; font-weight: bold;">0</span>, .tail = <span style="color: #268bd2; font-weight: bold;">0</span><span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">void</span> <span style="color: #268bd2;">enqueue</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Queue</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">Q</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">x</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  assert<span style="color: #b58900;">(</span>Q != <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #b58900;">)</span>;
  assert<span style="color: #b58900;">(</span>Q-&gt;head != <span style="color: #268bd2;">(</span>Q-&gt;tail+<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #268bd2;">)</span> % Q-&gt;capacity<span style="color: #b58900;">)</span>;

  Q-&gt;data<span style="color: #b58900;">[</span>Q-&gt;tail<span style="color: #b58900;">]</span> = x;
  Q-&gt;tail = <span style="color: #b58900;">(</span>Q-&gt;tail + <span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #b58900;">)</span> % Q-&gt;capacity;
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">dequeue</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Queue</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">Q</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  assert<span style="color: #b58900;">(</span>Q != <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #b58900;">)</span>;
  assert<span style="color: #b58900;">(</span><span style="color: #b58900; font-weight: bold;">!</span>queue_is_empty<span style="color: #268bd2;">(</span>Q<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>;

  <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">x</span> = Q-&gt;data<span style="color: #b58900;">[</span>Q-&gt;head<span style="color: #b58900;">]</span>;
  Q-&gt;head = <span style="color: #b58900;">(</span>Q-&gt;head+<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #b58900;">)</span> % Q-&gt;capacity;

  <span style="color: #859900; font-weight: bold;">return</span> x;
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">bool</span> <span style="color: #268bd2;">queue_is_empty</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Queue</span> <span style="color: #859900; font-weight: bold;">const</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">Q</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  assert<span style="color: #b58900;">(</span>Q != <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #b58900;">)</span>;
  <span style="color: #859900; font-weight: bold;">return</span> Q-&gt;head == Q-&gt;tail;
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">void</span> <span style="color: #268bd2;">queue_clear</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Queue</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">Q</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  Q-&gt;head = <span style="color: #268bd2; font-weight: bold;">0</span>;
  Q-&gt;tail = <span style="color: #268bd2; font-weight: bold;">0</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13"><span class="section-number-3">4.6</span> Flow</h3>
<div class="outline-text-3" id="text-4-6">
<p>
Now the Edmonds-Karp algorithm.
First two helper functions; it wouldn't be C if you didn't have to write everything yourself.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #93a1a1;">/*</span>
<span style="color: #93a1a1;"> * FLOW</span>
<span style="color: #93a1a1;"> </span><span style="color: #93a1a1;">*/</span>

<span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">min</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">a</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">b</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>a &lt; b<span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">return</span> a; <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #859900; font-weight: bold;">return</span> b;
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">max</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">a</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">b</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>a &gt; b<span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">return</span> a; <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #859900; font-weight: bold;">return</span> b;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p>
Then the actual algorithm where I have chosen to inline the breadth-first search.
We see how the <code>forwards</code> bit-flag is used to determine which way an edge goes, and thus whether we're adding flow to it or letting some of the flow take a different route.
Again, see Wikipedia for a description of the algorithm.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">edmonds_karp</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Graph</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">G</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">source</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">sink</span>, <span style="color: #b58900;">uint32_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">queue_data</span>, <span style="color: #b58900;">uint8_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">marked</span>, <span style="color: #b58900;">uint32_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">caps</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  assert<span style="color: #b58900;">(</span>G != <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #b58900;">)</span>;

  <span style="color: #b58900;">Edge</span> * <span style="color: #268bd2;">head</span>;
  <span style="color: #b58900;">Queue</span> <span style="color: #268bd2;">q</span> = queue_alloc<span style="color: #b58900;">(</span>queue_data, G-&gt;size<span style="color: #b58900;">)</span>;

  <span style="color: #859900; font-weight: bold;">do</span> <span style="color: #b58900;">{</span>
    queue_clear<span style="color: #268bd2;">(</span>&amp;q<span style="color: #268bd2;">)</span>;
    enqueue<span style="color: #268bd2;">(</span>&amp;q, source<span style="color: #268bd2;">)</span>;
    caps<span style="color: #268bd2;">[</span>source<span style="color: #268bd2;">]</span> = UINT_MAX;
    marked<span style="color: #268bd2;">[</span>source<span style="color: #268bd2;">]</span> = <span style="color: #268bd2; font-weight: bold;">1</span>;
    G-&gt;vertices<span style="color: #268bd2;">[</span>sink<span style="color: #268bd2;">]</span>.parent_edge = <span style="color: #268bd2; font-weight: bold;">NULL</span>;

    <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-weight: bold;">!</span>queue_is_empty<span style="color: #6c71c4;">(</span>&amp;q<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
      <span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">v</span> = dequeue<span style="color: #6c71c4;">(</span>&amp;q<span style="color: #6c71c4;">)</span>;

      <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #6c71c4;">(</span><span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">i</span> = <span style="color: #268bd2; font-weight: bold;">0</span>; i &lt; G-&gt;vertices<span style="color: #859900;">[</span>v<span style="color: #859900;">]</span>.size; i++<span style="color: #6c71c4;">)</span> <span style="color: #6c71c4;">{</span>
        <span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">u</span>;
        <span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">residual</span>;
        <span style="color: #b58900;">Edge</span> * <span style="color: #268bd2;">cur</span> = &amp;G-&gt;vertices<span style="color: #859900;">[</span>v<span style="color: #859900;">]</span>.edge_list<span style="color: #859900;">[</span>i<span style="color: #859900;">]</span>;

        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #859900;">(</span>cur-&gt;forwards<span style="color: #859900;">)</span> <span style="color: #859900;">{</span>
          u = cur-&gt;to;
          residual = cur-&gt;capacity - cur-&gt;flow;
        <span style="color: #859900;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #859900;">{</span>
          u = cur-&gt;from;
          residual = cur-&gt;flow;
        <span style="color: #859900;">}</span>

        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #859900;">(</span>residual &gt; <span style="color: #268bd2; font-weight: bold;">0</span> &amp;&amp; <span style="color: #b58900; font-weight: bold;">!</span>marked<span style="color: #b58900;">[</span>u<span style="color: #b58900;">]</span><span style="color: #859900;">)</span> <span style="color: #859900;">{</span>
          marked<span style="color: #b58900;">[</span>u<span style="color: #b58900;">]</span> = <span style="color: #268bd2; font-weight: bold;">1</span>;
          G-&gt;vertices<span style="color: #b58900;">[</span>u<span style="color: #b58900;">]</span>.parent_edge = cur;
          caps<span style="color: #b58900;">[</span>u<span style="color: #b58900;">]</span> = min<span style="color: #b58900;">(</span>caps<span style="color: #268bd2;">[</span>v<span style="color: #268bd2;">]</span>, residual<span style="color: #b58900;">)</span>;

          <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>u == sink<span style="color: #b58900;">)</span>
            <span style="color: #859900; font-weight: bold;">goto</span> <span style="color: #268bd2; font-weight: bold;">done</span>;

          enqueue<span style="color: #b58900;">(</span>&amp;q, u<span style="color: #b58900;">)</span>;
        <span style="color: #859900;">}</span>
      <span style="color: #6c71c4;">}</span>
    <span style="color: #268bd2;">}</span>

  <span style="color: #268bd2; font-weight: bold;">done</span>:
    head = G-&gt;vertices<span style="color: #268bd2;">[</span>sink<span style="color: #268bd2;">]</span>.parent_edge;

    <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #268bd2;">(</span>head != <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
      <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">idx</span>;

      <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #6c71c4;">(</span>head-&gt;forwards<span style="color: #6c71c4;">)</span> <span style="color: #6c71c4;">{</span>
        head-&gt;flow += caps<span style="color: #859900;">[</span>sink<span style="color: #859900;">]</span>;
        idx = head-&gt;from;
      <span style="color: #6c71c4;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #6c71c4;">{</span>
        head-&gt;flow -= caps<span style="color: #859900;">[</span>sink<span style="color: #859900;">]</span>;
        idx = head-&gt;to;
      <span style="color: #6c71c4;">}</span>

      head = G-&gt;vertices<span style="color: #6c71c4;">[</span>idx<span style="color: #6c71c4;">]</span>.parent_edge;
    <span style="color: #268bd2;">}</span>

    memset<span style="color: #268bd2;">(</span>marked, <span style="color: #268bd2; font-weight: bold;">0</span>, G-&gt;size * <span style="color: #859900; font-weight: bold;">sizeof</span> *marked<span style="color: #268bd2;">)</span>;

  <span style="color: #b58900;">}</span> <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #b58900;">(</span>G-&gt;vertices<span style="color: #268bd2;">[</span>sink<span style="color: #268bd2;">]</span>.parent_edge != <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #b58900;">)</span>;

  <span style="color: #b58900;">int32_t</span> <span style="color: #268bd2;">sum</span> = <span style="color: #268bd2; font-weight: bold;">0</span>;
  <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">i</span> = <span style="color: #268bd2; font-weight: bold;">0</span>; i &lt; G-&gt;vertices<span style="color: #268bd2;">[</span>source<span style="color: #268bd2;">]</span>.size; i++<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #b58900;">Edge</span> <span style="color: #268bd2;">cur</span> = G-&gt;vertices<span style="color: #268bd2;">[</span>source<span style="color: #268bd2;">]</span>.edge_list<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span>;
    sum += cur.forwards ? cur.flow : -cur.flow;
  <span style="color: #b58900;">}</span>

  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900;">(</span><span style="color: #b58900;">uint32_t</span><span style="color: #b58900;">)</span> sum;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p>
Another little helper for adding edges in both directions and avoiding adding useless ones.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #b58900;">void</span> <span style="color: #268bd2;">insert_flow_edge</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Graph</span> * <span style="color: #859900; font-weight: bold;">const</span>  <span style="color: #268bd2;">G</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">from</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">to</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">capacity</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  assert<span style="color: #b58900;">(</span>G != <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #b58900;">)</span>;

  <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>capacity == <span style="color: #268bd2; font-weight: bold;">0</span><span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">return</span>;

  insert_edge<span style="color: #b58900;">(</span>G, from, to, capacity, <span style="color: #268bd2; font-weight: bold;">true</span><span style="color: #b58900;">)</span>;
  insert_edge<span style="color: #b58900;">(</span>G, to, from, capacity, <span style="color: #268bd2; font-weight: bold;">false</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline14" class="outline-3">
<h3 id="orgheadline14"><span class="section-number-3">4.7</span> Sorting</h3>
<div class="outline-text-3" id="text-4-7">
<p>
I started out sorting a lot more than the one time I do now, so the sorting is optimized more than turned out to be necessary.
</p>

<p>
First we quicksort down to buckets of <code>SORT_CUTOFF</code>, 16, and then a single insertion sort is run over the entire array to put these buckets into order.
The asymptotic running time is the same, but because insertion sort has lower constants, this is faster.
</p>

<p>
I'm using the Hoare partitioning scheme as described by <a href="http://algs4.cs.princeton.edu/23quicksort/">Sedgewick and Wayne</a>.
The code is almost an exact replica of <a href="http://algs4.cs.princeton.edu/23quicksort/Quick.java.html">their implementation in Java</a>.
</p>

<p>
We see how nicely the function pointer works.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #93a1a1;">/*</span>
<span style="color: #93a1a1;"> * SORTING</span>
<span style="color: #93a1a1;"> </span><span style="color: #93a1a1;">*/</span>

<span style="color: #b58900;">void</span> <span style="color: #268bd2;">swap_platform</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> * <span style="color: #268bd2;">a</span>, <span style="color: #b58900;">Platform</span> * <span style="color: #268bd2;">b</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900;">Platform</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">t</span> = *a;
  *a = *b;
  *b = t;
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">bool</span> <span style="color: #268bd2;">lessxy</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">a</span>, <span style="color: #b58900;">Platform</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">b</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #859900; font-weight: bold;">return</span> a.x &lt; b.x || <span style="color: #b58900;">(</span>a.x == b.x &amp;&amp; a.y &lt; b.y<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">bool</span> <span style="color: #268bd2;">lessy</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">a</span>, <span style="color: #b58900;">Platform</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">b</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #859900; font-weight: bold;">return</span> a.y &lt; b.y;
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">partition</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">xs</span>, <span style="color: #b58900;">int</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">lo</span>, <span style="color: #b58900;">int</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">hi</span>, <span style="color: #b58900;">LESS</span> <span style="color: #268bd2;">less</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900;">int</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">idx</span> = rand<span style="color: #b58900;">()</span> % <span style="color: #b58900;">(</span>hi-lo+<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #b58900;">)</span> + lo;
  swap_platform<span style="color: #b58900;">(</span>xs+idx, xs+lo<span style="color: #b58900;">)</span>;

  <span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span> = lo;
  <span style="color: #b58900;">int</span> <span style="color: #268bd2;">j</span> = hi + <span style="color: #268bd2; font-weight: bold;">1</span>;
  <span style="color: #b58900;">Platform</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">x</span> = xs<span style="color: #b58900;">[</span>lo<span style="color: #b58900;">]</span>;

  <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">true</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #268bd2;">(</span>less<span style="color: #6c71c4;">(</span>xs<span style="color: #859900;">[</span>++i<span style="color: #859900;">]</span>, x<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>
      <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>i == hi<span style="color: #268bd2;">)</span> <span style="color: #859900; font-weight: bold;">break</span>;

    <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #268bd2;">(</span>less<span style="color: #6c71c4;">(</span>x, xs<span style="color: #859900;">[</span>--j<span style="color: #859900;">]</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>
      <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>j == lo<span style="color: #268bd2;">)</span> <span style="color: #859900; font-weight: bold;">break</span>;

    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>i &gt;= j<span style="color: #268bd2;">)</span> <span style="color: #859900; font-weight: bold;">break</span>;

    swap_platform<span style="color: #268bd2;">(</span>xs+i, xs+j<span style="color: #268bd2;">)</span>;
  <span style="color: #b58900;">}</span>

  swap_platform<span style="color: #b58900;">(</span>xs+lo, xs+j<span style="color: #b58900;">)</span>;

  <span style="color: #859900; font-weight: bold;">return</span> j;
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">void</span> <span style="color: #268bd2;">quicksort</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">xs</span>, <span style="color: #b58900;">int</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">lo</span>, <span style="color: #b58900;">int</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">hi</span>, <span style="color: #b58900;">LESS</span> <span style="color: #268bd2;">less</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>hi - lo &gt; SORT_CUTOFF<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #b58900;">int</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">p</span> = partition<span style="color: #268bd2;">(</span>xs, lo, hi, less<span style="color: #268bd2;">)</span>;
    quicksort<span style="color: #268bd2;">(</span>xs, lo, p-<span style="color: #268bd2; font-weight: bold;">1</span>, less<span style="color: #268bd2;">)</span>;
    quicksort<span style="color: #268bd2;">(</span>xs, p+<span style="color: #268bd2; font-weight: bold;">1</span>, hi, less<span style="color: #268bd2;">)</span>;
  <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">void</span> <span style="color: #268bd2;">insertion_sort</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">xs</span>, <span style="color: #b58900;">size_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">len</span>, <span style="color: #b58900;">LESS</span> <span style="color: #268bd2;">less</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">i</span> = <span style="color: #268bd2; font-weight: bold;">1</span>; i &lt; len; i++<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #b58900;">Platform</span> <span style="color: #268bd2;">x</span> = xs<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span>;
    <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">j</span> = i;

    <span style="color: #859900; font-weight: bold;">while</span><span style="color: #268bd2;">(</span>j &gt; <span style="color: #268bd2; font-weight: bold;">0</span> &amp;&amp; less<span style="color: #6c71c4;">(</span>x, xs<span style="color: #859900;">[</span>j-<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #859900;">]</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
      xs<span style="color: #6c71c4;">[</span>j<span style="color: #6c71c4;">]</span> = xs<span style="color: #6c71c4;">[</span>j-<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #6c71c4;">]</span>;
      j--;
    <span style="color: #268bd2;">}</span>

    xs<span style="color: #268bd2;">[</span>j<span style="color: #268bd2;">]</span> = x;
  <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">void</span> <span style="color: #268bd2;">sort</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ps</span>, <span style="color: #b58900;">size_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">P</span>, <span style="color: #b58900;">LESS</span> <span style="color: #268bd2;">less</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  quicksort<span style="color: #b58900;">(</span>ps, <span style="color: #268bd2; font-weight: bold;">0</span>, <span style="color: #268bd2;">(</span><span style="color: #b58900;">int</span><span style="color: #268bd2;">)</span> P-<span style="color: #268bd2; font-weight: bold;">1</span>, less<span style="color: #b58900;">)</span>;
  insertion_sort<span style="color: #b58900;">(</span>ps, P, less<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline15" class="outline-3">
<h3 id="orgheadline15"><span class="section-number-3">4.8</span> Hashing</h3>
<div class="outline-text-3" id="text-4-8">
<p>
For the hash table I'm just using a simple linear probing technique.
The slopes turn out to be really well distributed and I'm using a load factor of at most \(\frac15\), so clustering is minimal and this turns out to work nicely.
</p>

<p>
Because the counts are stored as single byte we don't want to increment it unnecessarily and risk an overflow.
Fortunately the compiler seems to optimize the very straight-forward code really well.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #93a1a1;">/*</span>
<span style="color: #93a1a1;"> * HASHING</span>
<span style="color: #93a1a1;"> </span><span style="color: #93a1a1;">*/</span>

<span style="color: #b58900;">bool</span> <span style="color: #268bd2;">update_slope_count</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">uint32_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">slopes</span>, <span style="color: #b58900;">uint8_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">counts</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">slopes_len</span>, <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">key</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  assert<span style="color: #b58900;">(</span>slopes != <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #b58900;">)</span>;

  <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">idx</span> = key % slopes_len;; idx++, idx %= slopes_len<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>counts<span style="color: #6c71c4;">[</span>idx<span style="color: #6c71c4;">]</span> == <span style="color: #268bd2; font-weight: bold;">0</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
      counts<span style="color: #6c71c4;">[</span>idx<span style="color: #6c71c4;">]</span> = <span style="color: #268bd2; font-weight: bold;">1</span>;
      slopes<span style="color: #6c71c4;">[</span>idx<span style="color: #6c71c4;">]</span> = key;
      <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>;
    <span style="color: #268bd2;">}</span>

    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>slopes<span style="color: #6c71c4;">[</span>idx<span style="color: #6c71c4;">]</span> == key<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
      <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #6c71c4;">(</span>counts<span style="color: #859900;">[</span>idx<span style="color: #859900;">]</span> &gt;= <span style="color: #268bd2; font-weight: bold;">2</span><span style="color: #6c71c4;">)</span> <span style="color: #6c71c4;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span>;
      <span style="color: #6c71c4;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #6c71c4;">{</span>
        counts<span style="color: #859900;">[</span>idx<span style="color: #859900;">]</span>++;
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>;
      <span style="color: #6c71c4;">}</span>
    <span style="color: #268bd2;">}</span>
  <span style="color: #b58900;">}</span>

  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>

<p>
Because we're hashing so much, it's worth spending a tiny amount of time finding a prime to hash against for better distribution.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">next_prime</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">a</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">x</span> = a;; x++<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>x % <span style="color: #268bd2; font-weight: bold;">2</span> == <span style="color: #268bd2; font-weight: bold;">0</span><span style="color: #268bd2;">)</span> <span style="color: #859900; font-weight: bold;">continue</span>;
    <span style="color: #b58900;">bool</span> <span style="color: #268bd2;">is_prime</span> = <span style="color: #268bd2; font-weight: bold;">true</span>;
    <span style="color: #b58900;">double</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">limit</span> = sqrt<span style="color: #268bd2;">(</span>x<span style="color: #268bd2;">)</span>;
    <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #268bd2;">(</span><span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">i</span> = <span style="color: #268bd2; font-weight: bold;">3</span>; i &lt;= limit; i += <span style="color: #268bd2; font-weight: bold;">2</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
      <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #6c71c4;">(</span>x % i == <span style="color: #268bd2; font-weight: bold;">0</span><span style="color: #6c71c4;">)</span> <span style="color: #6c71c4;">{</span>
        is_prime = <span style="color: #268bd2; font-weight: bold;">false</span>;
        <span style="color: #859900; font-weight: bold;">break</span>;
      <span style="color: #6c71c4;">}</span>
    <span style="color: #268bd2;">}</span>
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>is_prime<span style="color: #268bd2;">)</span> <span style="color: #859900; font-weight: bold;">return</span> x;
  <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline16" class="outline-3">
<h3 id="orgheadline16"><span class="section-number-3">4.9</span> Convex Hull</h3>
<div class="outline-text-3" id="text-4-9">
<p>
Create the convex hull in linear time given sorted input by finding upper and lower hulls.
This is very nice since we already sort the input to do the A1-activities so constructing this is cheap as described.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #93a1a1;">/*</span>
<span style="color: #93a1a1;"> * CONVEX HULL</span>
<span style="color: #93a1a1;"> </span><span style="color: #93a1a1;">*/</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">ccw</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> * <span style="color: #268bd2;">p1</span>, <span style="color: #b58900;">Platform</span> * <span style="color: #268bd2;">p2</span>, <span style="color: #b58900;">Platform</span> * <span style="color: #268bd2;">p3</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900;">(</span>p2-&gt;x - p1-&gt;x<span style="color: #b58900;">)</span>*<span style="color: #b58900;">(</span>p3-&gt;y - p1-&gt;y<span style="color: #b58900;">)</span> - <span style="color: #b58900;">(</span>p2-&gt;y - p1-&gt;y<span style="color: #b58900;">)</span>*<span style="color: #b58900;">(</span>p3-&gt;x - p1-&gt;x<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">void</span> <span style="color: #268bd2;">convex_hull</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Platform</span> * <span style="color: #268bd2;">points</span>, <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">npoints</span>, <span style="color: #b58900;">Platform</span> ** <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">out_hull</span>, <span style="color: #b58900;">size_t</span> * <span style="color: #268bd2;">out_hullsize</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900;">Platform</span> * <span style="color: #268bd2;">hull</span>;
  <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">t</span>, <span style="color: #268bd2;">k</span> = <span style="color: #268bd2; font-weight: bold;">0</span>;
  <span style="color: #b58900;">int64_t</span> <span style="color: #268bd2;">i</span>;

  hull = *out_hull;

  <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span>i = <span style="color: #268bd2; font-weight: bold;">0</span>; i &lt; <span style="color: #268bd2;">(</span><span style="color: #b58900;">int64_t</span><span style="color: #268bd2;">)</span> npoints; ++i<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #268bd2;">(</span>k &gt;= <span style="color: #268bd2; font-weight: bold;">2</span> &amp;&amp; ccw<span style="color: #6c71c4;">(</span>&amp;hull<span style="color: #859900;">[</span>k-<span style="color: #268bd2; font-weight: bold;">2</span><span style="color: #859900;">]</span>, &amp;hull<span style="color: #859900;">[</span>k-<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #859900;">]</span>, &amp;points<span style="color: #859900;">[</span>i<span style="color: #859900;">]</span><span style="color: #6c71c4;">)</span> &lt;= <span style="color: #268bd2; font-weight: bold;">0</span><span style="color: #268bd2;">)</span> --k;
    hull<span style="color: #268bd2;">[</span>k++<span style="color: #268bd2;">]</span> = points<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span>;
  <span style="color: #b58900;">}</span>

  <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span>i = <span style="color: #268bd2;">(</span><span style="color: #b58900;">int64_t</span><span style="color: #268bd2;">)</span> npoints-<span style="color: #268bd2; font-weight: bold;">2</span>, t = k+<span style="color: #268bd2; font-weight: bold;">1</span>; i &gt;= <span style="color: #268bd2; font-weight: bold;">0</span>; i--<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #268bd2;">(</span>k &gt;= t &amp;&amp; ccw<span style="color: #6c71c4;">(</span>&amp;hull<span style="color: #859900;">[</span>k-<span style="color: #268bd2; font-weight: bold;">2</span><span style="color: #859900;">]</span>, &amp;hull<span style="color: #859900;">[</span>k-<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #859900;">]</span>, &amp;points<span style="color: #859900;">[</span>i<span style="color: #859900;">]</span><span style="color: #6c71c4;">)</span> &lt;= <span style="color: #268bd2; font-weight: bold;">0</span><span style="color: #268bd2;">)</span> --k;
    hull<span style="color: #268bd2;">[</span>k++<span style="color: #268bd2;">]</span> = points<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span>;
  <span style="color: #b58900;">}</span>

  *out_hull = hull;
  *out_hullsize = k;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline17" class="outline-3">
<h3 id="orgheadline17"><span class="section-number-3">4.10</span> Main</h3>
<div class="outline-text-3" id="text-4-10">
<p>
Finally the main function.
There's some benchmarking stuff in there behind the <code>ifndef</code>.
</p>

<p>
The random number generator is seeded for the quicksort, which uses a random pivot.
</p>

<p>
Then I do all the allocation aside from the adjacency lists up front.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #93a1a1;">/*</span>
<span style="color: #93a1a1;"> * MAIN</span>
<span style="color: #93a1a1;"> </span><span style="color: #93a1a1;">*/</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
<span style="color: #268bd2;">#if</span><span style="color: #268bd2; font-weight: bold;">n</span><span style="color: #268bd2;">def</span> CODEJUDGE
  <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">timeval</span> <span style="color: #268bd2;">t1</span>, <span style="color: #268bd2;">t2</span>, <span style="color: #268bd2;">t3</span>, <span style="color: #268bd2;">t4</span>, <span style="color: #268bd2;">t5</span>, <span style="color: #268bd2;">t6</span>, <span style="color: #268bd2;">t7</span>;
  gettimeofday<span style="color: #b58900;">(</span>&amp;t1, <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #b58900;">)</span>;
<span style="color: #268bd2;">#endif</span>

  srand<span style="color: #b58900;">(</span><span style="color: #268bd2;">(</span><span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">int</span><span style="color: #268bd2;">)</span> time<span style="color: #268bd2;">(</span><span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>;

  <span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">P</span>;
  <span style="color: #b58900;">char</span> <span style="color: #268bd2;">line</span><span style="color: #b58900;">[</span>MAX_LINE<span style="color: #b58900;">]</span>;

  fgets<span style="color: #b58900;">(</span>line, MAX_LINE, stdin<span style="color: #b58900;">)</span>;
  sscanf<span style="color: #b58900;">(</span>line, <span style="color: #2aa198;">"%d"</span>, &amp;P<span style="color: #b58900;">)</span>;

  <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">n_slopes</span> = next_prime<span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">5</span>*P<span style="color: #b58900;">)</span>;

  <span style="color: #b58900;">Platform</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ps</span> = malloc<span style="color: #b58900;">(</span><span style="color: #b58900;">P</span> * <span style="color: #859900; font-weight: bold;">sizeof</span> *ps<span style="color: #b58900;">)</span>;
  <span style="color: #b58900;">Vertex</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">vertices</span> = malloc<span style="color: #b58900;">(</span>VERTEX_FACTOR*P * <span style="color: #859900; font-weight: bold;">sizeof</span> *vertices<span style="color: #b58900;">)</span>;
  <span style="color: #b58900;">uint32_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">slopes</span> = malloc<span style="color: #b58900;">(</span><span style="color: #b58900;">n_slopes</span> * <span style="color: #859900; font-weight: bold;">sizeof</span> *slopes<span style="color: #b58900;">)</span>;
  <span style="color: #b58900;">uint8_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">counts</span> = calloc<span style="color: #b58900;">(</span>n_slopes, <span style="color: #859900; font-weight: bold;">sizeof</span> *counts<span style="color: #b58900;">)</span>;
  <span style="color: #b58900;">uint32_t</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">caps</span> = malloc<span style="color: #b58900;">(</span>VERTEX_FACTOR*P * <span style="color: #859900; font-weight: bold;">sizeof</span> *caps<span style="color: #b58900;">)</span>;
  <span style="color: #b58900;">Platform</span> * <span style="color: #268bd2;">hull</span> = malloc<span style="color: #b58900;">(</span><span style="color: #268bd2;">(</span>P+<span style="color: #268bd2; font-weight: bold;">1</span><span style="color: #268bd2;">)</span> * <span style="color: #859900; font-weight: bold;">sizeof</span> *hull<span style="color: #b58900;">)</span>;

  <span style="color: #b58900;">Graph</span> <span style="color: #268bd2;">G</span> = graph_alloc<span style="color: #b58900;">(</span>vertices, VERTEX_FACTOR*P<span style="color: #b58900;">)</span>;
</pre>
</div>

<p>
Read in the input.
</p>

<div class="org-src-container">

<pre class="src src-c">  <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">i</span> = <span style="color: #268bd2; font-weight: bold;">0</span>; i &lt; P; i++<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    fgets<span style="color: #b58900;">(</span>line, MAX_LINE, stdin<span style="color: #b58900;">)</span>;
    sscanf<span style="color: #b58900;">(</span>line, <span style="color: #2aa198;">"%d %d %u %u %u %u"</span>, &amp;ps<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span>.x, &amp;ps<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span>.y, &amp;ps<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span>.a1, &amp;ps<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span>.a2, &amp;ps<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span>.a3, &amp;ps<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span>.a4<span style="color: #b58900;">)</span>;
    ps<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span>.n = i;
  <span style="color: #2aa198;">}</span>

<span style="color: #268bd2;">#if</span><span style="color: #268bd2; font-weight: bold;">n</span><span style="color: #268bd2;">def</span> CODEJUDGE
  gettimeofday<span style="color: #2aa198;">(</span>&amp;t2, <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #2aa198;">)</span>;
<span style="color: #268bd2;">#endif</span>
</pre>
</div>

<p>
Construct the A1-activities as described: Sort the platforms so candidates are next to each other and then run through and construct them as long as the coordinates match.
</p>

<div class="org-src-container">

<pre class="src src-c">  <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Vertex schema:</span>
<span style="color: #93a1a1;">   * i: ingoing (original vertex)</span>
<span style="color: #93a1a1;">   * i+1*P: A1</span>
<span style="color: #93a1a1;">   * i+2*P: A3</span>
<span style="color: #93a1a1;">   * There can only be one of each of A2 and A4,</span>
<span style="color: #93a1a1;">   * so we don't need the dummy vertices for these</span>
<span style="color: #93a1a1;">   </span><span style="color: #93a1a1;">*/</span>

  <span style="color: #93a1a1;">/*</span>
<span style="color: #93a1a1;">   * A1 (NEWS)</span>
<span style="color: #93a1a1;">   </span><span style="color: #93a1a1;">*/</span>

  sort<span style="color: #2aa198;">(</span>ps, P, lessy<span style="color: #2aa198;">)</span>;

  <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">i</span> = <span style="color: #268bd2; font-weight: bold;">0</span>; i &lt; P; i++<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">Platform</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">p</span> = ps<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span>;
    <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">j</span> = i+<span style="color: #268bd2; font-weight: bold;">1</span>; j &lt; P &amp;&amp; ps<span style="color: #268bd2;">[</span>j<span style="color: #268bd2;">]</span>.y == p.y; j++<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
      insert_flow_edge<span style="color: #268bd2;">(</span>&amp;G, p.n+P, ps<span style="color: #6c71c4;">[</span>j<span style="color: #6c71c4;">]</span>.n, p.a1<span style="color: #268bd2;">)</span>;
      insert_flow_edge<span style="color: #268bd2;">(</span>&amp;G, ps<span style="color: #6c71c4;">[</span>j<span style="color: #6c71c4;">]</span>.n+P, p.n, ps<span style="color: #6c71c4;">[</span>j<span style="color: #6c71c4;">]</span>.a1<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>
   <span style="color: #2aa198;">}</span>

  sort<span style="color: #2aa198;">(</span>ps, P, lessxy<span style="color: #2aa198;">)</span>;

  <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">i</span> = <span style="color: #268bd2; font-weight: bold;">0</span>; i &lt; P; i++<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">Platform</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">p</span> = ps<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span>;
    <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">j</span> = i+<span style="color: #268bd2; font-weight: bold;">1</span>; j &lt; P &amp;&amp; ps<span style="color: #268bd2;">[</span>j<span style="color: #268bd2;">]</span>.x == p.x; j++<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
      insert_flow_edge<span style="color: #268bd2;">(</span>&amp;G, p.n+P, ps<span style="color: #6c71c4;">[</span>j<span style="color: #6c71c4;">]</span>.n, p.a1<span style="color: #268bd2;">)</span>;
      insert_flow_edge<span style="color: #268bd2;">(</span>&amp;G, ps<span style="color: #6c71c4;">[</span>j<span style="color: #6c71c4;">]</span>.n+P, p.n, ps<span style="color: #6c71c4;">[</span>j<span style="color: #6c71c4;">]</span>.a1<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>
   <span style="color: #2aa198;">}</span>

<span style="color: #268bd2;">#if</span><span style="color: #268bd2; font-weight: bold;">n</span><span style="color: #268bd2;">def</span> CODEJUDGE
  gettimeofday<span style="color: #2aa198;">(</span>&amp;t3, <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #2aa198;">)</span>;
<span style="color: #268bd2;">#endif</span>
</pre>
</div>

<p>
Now the platforms are sorted so we can create the convex hull and use this for constructing A2-activities to the platforms furthest away.
</p>

<div class="org-src-container">

<pre class="src src-c">  <span style="color: #93a1a1;">/*</span>
<span style="color: #93a1a1;">   * A2 (Human Cannon)</span>
<span style="color: #93a1a1;">   </span><span style="color: #93a1a1;">*/</span>

  <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">hull_size</span>;
  convex_hull<span style="color: #2aa198;">(</span>ps, P, &amp;hull, &amp;hull_size<span style="color: #2aa198;">)</span>;

  <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">i</span> = <span style="color: #268bd2; font-weight: bold;">0</span>; i &lt; P; i++<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">Platform</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">p</span> = ps<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span>;
    <span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">furthest</span> = UINT_MAX;
    <span style="color: #b58900;">int64_t</span> <span style="color: #268bd2;">furthest_dist</span> = <span style="color: #268bd2; font-weight: bold;">0</span>;

    <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">j</span> = <span style="color: #268bd2; font-weight: bold;">0</span>; j &lt; <span style="color: #268bd2;">(</span><span style="color: #b58900;">size_t</span><span style="color: #268bd2;">)</span> hull_size; j++<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
      <span style="color: #b58900;">Platform</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">q</span> = hull<span style="color: #268bd2;">[</span>j<span style="color: #268bd2;">]</span>;
      <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>p.n == q.n<span style="color: #268bd2;">)</span> <span style="color: #859900; font-weight: bold;">continue</span>;

      <span style="color: #b58900;">int64_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">dx</span> = p.x - q.x, <span style="color: #268bd2;">dy</span> = p.y - q.y;
      <span style="color: #b58900;">int64_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">dist</span> = dx*dx + dy*dy;

      <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>dist &gt; furthest_dist || <span style="color: #6c71c4;">(</span>dist == furthest_dist &amp;&amp; q.n &lt; furthest<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
        furthest = q.n;
        furthest_dist = dist;
      <span style="color: #268bd2;">}</span>
    <span style="color: #b58900;">}</span>

    insert_flow_edge<span style="color: #b58900;">(</span>&amp;G, p.n, furthest, p.a2<span style="color: #b58900;">)</span>;
   <span style="color: #2aa198;">}</span>

<span style="color: #268bd2;">#if</span><span style="color: #268bd2; font-weight: bold;">n</span><span style="color: #268bd2;">def</span> CODEJUDGE
  gettimeofday<span style="color: #2aa198;">(</span>&amp;t4, <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #2aa198;">)</span>;
<span style="color: #268bd2;">#endif</span>
</pre>
</div>

<p>
I was very curious how to hash floating point values, but simply copying the bits verbatim into an unsigned integer works really well.
I use this as the key also instead of the float, because they are identical anyway and this avoids a warning about unsafe comparison of floating point values.
</p>

<p>
Two arrays comprise the hash table, the slopes/keys and counts/values and it is enough to clear the counts to clear the hash table as I've implemented it.
This saves a constant factor because the byte array of counts takes up a quarter of the space of the 4 byte slopes.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #93a1a1;">/*</span>
<span style="color: #93a1a1;"> * A3 (Platform Trampoline)</span>
<span style="color: #93a1a1;"> </span><span style="color: #93a1a1;">*/</span>

<span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">i</span> = <span style="color: #268bd2; font-weight: bold;">0</span>; i &lt; P; i++<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900;">Platform</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">p</span> = ps<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span>;
  <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>p.a3 == <span style="color: #268bd2; font-weight: bold;">0</span><span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">continue</span>;

  <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">j</span> = i+<span style="color: #268bd2; font-weight: bold;">1</span>; j &lt; P; j++<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #b58900;">Platform</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">q</span> = ps<span style="color: #268bd2;">[</span>j<span style="color: #268bd2;">]</span>;

    <span style="color: #b58900;">int64_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">dx</span> = p.x - q.x, <span style="color: #268bd2;">dy</span> = p.y - q.y;
    <span style="color: #b58900;">float</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">fslope</span> = <span style="color: #268bd2;">(</span><span style="color: #b58900;">float</span><span style="color: #268bd2;">)</span> dy / dx;
    <span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">slope</span>;
    memcpy<span style="color: #268bd2;">(</span>&amp;slope, &amp;fslope, <span style="color: #859900; font-weight: bold;">sizeof</span> slope<span style="color: #268bd2;">)</span>;

    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>update_slope_count<span style="color: #6c71c4;">(</span>slopes, counts, n_slopes, slope<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
      insert_flow_edge<span style="color: #6c71c4;">(</span>&amp;G, p.n+<span style="color: #268bd2; font-weight: bold;">2</span>*P, q.n, p.a3<span style="color: #6c71c4;">)</span>;
      insert_flow_edge<span style="color: #6c71c4;">(</span>&amp;G, q.n+<span style="color: #268bd2; font-weight: bold;">2</span>*P, p.n, q.a3<span style="color: #6c71c4;">)</span>;
    <span style="color: #268bd2;">}</span>
  <span style="color: #b58900;">}</span>

  memset<span style="color: #b58900;">(</span>counts, <span style="color: #268bd2; font-weight: bold;">0</span>, <span style="color: #b58900;">n_slopes</span> * <span style="color: #859900; font-weight: bold;">sizeof</span> *counts<span style="color: #b58900;">)</span>;
 <span style="color: #2aa198;">}</span>
</pre>
</div>

<p>
Finally the simplest of activities; so simple that we can easily manage to connect the dummy vertices as well.
</p>

<div class="org-src-container">

<pre class="src src-c">  <span style="color: #93a1a1;">/*</span>
<span style="color: #93a1a1;">   * A4 (EOF)</span>
<span style="color: #93a1a1;">   * vertex -&gt; edge capacities</span>
<span style="color: #93a1a1;">   </span><span style="color: #93a1a1;">*/</span>

  <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">uint32_t</span> <span style="color: #268bd2;">i</span> = <span style="color: #268bd2; font-weight: bold;">0</span>; i &lt; P; i++<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">Platform</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">p</span> = ps<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span>;

    insert_flow_edge<span style="color: #b58900;">(</span>&amp;G, p.n, p.n+  P, p.a1<span style="color: #b58900;">)</span>;
    insert_flow_edge<span style="color: #b58900;">(</span>&amp;G, p.n, p.n+<span style="color: #268bd2; font-weight: bold;">2</span>*P, p.a3<span style="color: #b58900;">)</span>;

    insert_flow_edge<span style="color: #b58900;">(</span>&amp;G, p.n, P-<span style="color: #268bd2; font-weight: bold;">1</span>, p.a4<span style="color: #b58900;">)</span>;
  <span style="color: #2aa198;">}</span>

<span style="color: #268bd2;">#if</span><span style="color: #268bd2; font-weight: bold;">n</span><span style="color: #268bd2;">def</span> CODEJUDGE
  gettimeofday<span style="color: #2aa198;">(</span>&amp;t6, <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #2aa198;">)</span>;
<span style="color: #268bd2;">#endif</span>
</pre>
</div>

<p>
Run the flow algorithm, print the result and free the memory.
Freeing the adjacency tables takes too long because we need to iterate over all the vertices, so I only do that locally.
</p>

<p>
In the end I print some running times for testing.
</p>

<div class="org-src-container">

<pre class="src src-c">  <span style="color: #93a1a1;">/*</span>
<span style="color: #93a1a1;">   * FLOW</span>
<span style="color: #93a1a1;">   </span><span style="color: #93a1a1;">*/</span>

  <span style="color: #b58900;">uint32_t</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">flow</span> = edmonds_karp<span style="color: #2aa198;">(</span>&amp;G, <span style="color: #268bd2; font-weight: bold;">0</span>, P-<span style="color: #268bd2; font-weight: bold;">1</span>, slopes, counts, caps<span style="color: #2aa198;">)</span>;
  printf<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"%u\n"</span>, flow<span style="color: #2aa198;">)</span>;

  free<span style="color: #2aa198;">(</span>ps<span style="color: #2aa198;">)</span>;
  free<span style="color: #2aa198;">(</span>slopes<span style="color: #2aa198;">)</span>;
  free<span style="color: #2aa198;">(</span>counts<span style="color: #2aa198;">)</span>;
  free<span style="color: #2aa198;">(</span>caps<span style="color: #2aa198;">)</span>;
  free<span style="color: #2aa198;">(</span>hull<span style="color: #2aa198;">)</span>;

<span style="color: #268bd2;">#if</span><span style="color: #268bd2; font-weight: bold;">n</span><span style="color: #268bd2;">def</span> CODEJUDGE
  gettimeofday<span style="color: #2aa198;">(</span>&amp;t7, <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #2aa198;">)</span>;

  graph_free<span style="color: #2aa198;">(</span>&amp;G<span style="color: #2aa198;">)</span>;
  free<span style="color: #2aa198;">(</span>vertices<span style="color: #2aa198;">)</span>;

  <span style="color: #b58900;">double</span> <span style="color: #859900; font-weight: bold;">const</span>
    <span style="color: #268bd2;">input_time</span> = MS<span style="color: #2aa198;">(</span>t1, t2<span style="color: #2aa198;">)</span>,
    <span style="color: #268bd2;">a1_time</span> = MS<span style="color: #2aa198;">(</span>t2, t3<span style="color: #2aa198;">)</span>,
    <span style="color: #268bd2;">a2_time</span> = MS<span style="color: #2aa198;">(</span>t3, t4<span style="color: #2aa198;">)</span>,
    <span style="color: #268bd2;">a3_time</span> = MS<span style="color: #2aa198;">(</span>t4, t5<span style="color: #2aa198;">)</span>,
    <span style="color: #268bd2;">a4_time</span> = MS<span style="color: #2aa198;">(</span>t5, t6<span style="color: #2aa198;">)</span>,
    <span style="color: #268bd2;">flow_time</span> = MS<span style="color: #2aa198;">(</span>t6, t7<span style="color: #2aa198;">)</span>,
    <span style="color: #268bd2;">total_time</span> = MS<span style="color: #2aa198;">(</span>t1, t7<span style="color: #2aa198;">)</span>;

  printf<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"IN: %4.2f, A1: %5.2f, A2: %5.2f, A3: %6.2f, A4: %3.2f, FLOW: %4.2f, TOTAL: %6.2f\n"</span>, input_time, a1_time, a2_time, a3_time, a4_time, flow_time, total_time<span style="color: #2aa198;">)</span>;
<span style="color: #268bd2;">#endif</span>

  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">0</span>;
<span style="color: #657b83; background-color: #fdf6e3;">}</span>
</pre>
</div>

<p>
And we're done.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline19" class="outline-2">
<h2 id="orgheadline19"><span class="section-number-2">5</span> Sample running times</h2>
<div class="outline-text-2" id="text-5">
<p>
I've included the input size (in parenthesis) and running times for the largest input given, in table <a href="#orgsrcblock2">2</a>, generated by the implementation.
The time taken to solve different inputs of the same size can vary greatly based on how many platforms are on line, their capacities etc.
This is just to get an idea about where the time is spent.
</p>

<div class="org-src-container">
<label class="org-src-name">Running times for the largest inputs in milliseconds</label>
<pre class="src src-text" id="orgsrcblock2">2680 (2000)
IN: 1.74, A1:  6.17, A2:  0.28, A3:  48.77, A4: 0.38, FLOW: 0.26, TOTAL:  57.60
7632 (4000)
IN: 2.88, A1: 32.82, A2:  0.40, A3: 252.31, A4: 1.01, FLOW: 0.72, TOTAL: 290.14
199880 (5000)
IN: 5.80, A1:  6.22, A2:  0.61, A3: 135.04, A4: 0.94, FLOW: 0.19, TOTAL: 148.80
2420 (6000)
IN: 4.91, A1:  3.30, A2:  1.30, A3: 167.06, A4: 2.39, FLOW: 0.06, TOTAL: 179.02
70404 (8000)
IN: 6.50, A1:  8.21, A2:  0.74, A3: 339.12, A4: 2.34, FLOW: 0.13, TOTAL: 357.03
</pre>
</div>

<p>
A3 dominates greatly.
</p>
</div>
</div>

<div id="outline-container-orgheadline20" class="outline-2">
<h2 id="orgheadline20"><span class="section-number-2">6</span> License</h2>
<div class="outline-text-2" id="text-6">
<p>
Copyright  2015 Andreas H. From
</p>

<p>
Distributed under the MIT License.
</p>

<p>
This applies of course only to my code, text and figures, not necessarily anything linked from this page.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara">North, East, West, South</div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara">End-Of-Fun</div></div>


</div>
</div></div>
</body>
</html>
